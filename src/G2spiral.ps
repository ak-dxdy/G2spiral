%!PS-Adobe-3.0
%%BoundingBox: 0 0 595 842
%
% gv -infoErrors -geometry 1000x1000 -arg="-sFname=g2.txt"  Demo.ps &
% gv -infoAll                        -arg="-sFname=g2.txt"  Demo.ps &
%
(Start) ==

% You can modify this script, adjusting it to your own needs as explained below.
% You can view this (or modified) script
%     under Windows: by opening it in GSVIEW and other available PostScript viewers;
%     under Unix:    by opening it in command line as "gv filename.ps" (and other PostScript viewers);
% You can convert this script to PDF format by various converters, e.g., ImageMagic's convert.exe
%  
%  Edit below this line -------------------------------------------
<<
   /UserG2Data [/XYTK8 -82.64 -20. 300  0.025  48.55 23.5 -20.0 -0.04 ] 
>> 
%  Edit above this line -------------------------------------------

/Fname where {%
   pop Fname ==
   clear Fname run 
} {/Fname () def} ifelse


% Parabola with elliptic Solutions
%/p .5 def /q .5 def /hh1 1 p add dup mul q dup mul add def 
%                    /hh2 1 p sub dup mul q dup mul add def 


%    For an example with short spirals (0 < p1 < p2), simply uncomment the line below:
%  /UserG2Data [ 90 30 0.2  1. 0]  def
%    For an example with long spirals within   bounded region, uncomment the line below:
%                          90 30 -0.2 -1 
%    For an example with long spirals within unbounded region, uncomment the line below:
%                          90 30 -0.2 -1 
%    Data such that sin(alpha+beta)=0 or p1*p2 < 0  cause error.

% ================= Load some entries from FigDict:

/FigDict 111 dict def       % 105
/DebugMode /TeXDict where dup {exch pop} if not def % DebugMode = true/false

/CurrentScale {%  calculate  +-sqrt(|ad-bc|) from [a b c d tx ty]
   matrix currentmatrix aload pop pop pop 4 -1 roll mul 3 1 roll mul sub 
   dup abs sqrt exch 0 lt {neg} if
} bind def

/BeginFig {%
countdictstack
FigDict begin  
  /DictCheck exch def
  gsave true setstrokeadjust .5 dup translate
      [] ArrowSet 
      /PicDict
      <<  /PicX1 0 /PicX2 500 /PicY1 0 /PicY2 800 /PicW 500 /PicH 800 
          /PicScal 1. /PicMX matrix 
          /IniScal CurrentScale 
          /PicMinus (\261)
      >> def
%      /TcleanW .15 def   % Tclean_Width parameter
      /KdrawLength 100 def
      true setstrokeadjust
end      
} bind def

/EndFig {%   ? check stack and dict_stack ?
  grestore
  gsave 1 0 0 setrgbcolor 4 setlinewidth
        DebugMode 
        {count 0 ne 
          {Pstack 0 0 moveto 600 840 lineto 600 0 moveto 0 840 lineto stroke} if % StackNotEmpty
         countdictstack DictCheck ne 
          {0 0 100 0 360 arc stroke} if                % Dict_not_popped
        } if
        flush  
  grestore      
} bind def

%(GenSec.ps)      runlibfile
%!
% --------------------------------------------------------- GenSec.ps start
%        "General Section Library"
% ========================================================= Main constants (userdict)
/Pi   3.14159265358979323846 def
/PiPi Pi 2 mul def
/Pi90 Pi 2 div def
/Radian 180. Pi div def 
/ED {exch def} bind def

/AppStr  {% <str1> <str2> appstr <str3> % borrowed from Ghostscript
    exch dup length 2 index length add string
    dup dup 4 2 roll copy
    length 4 -1 roll putinterval
}bind def

% ============================================ Debugging procedures (userdict)

/Pdef {2 copy [ 3 1 roll (def)] == def} bind def

/Pstack {%
  count [exch dup (items on stack:) 3 -1 roll % S0 S1 ... S_n-1 [N (txt) N
      dup 3 add exch                          % S0 S1 ... S_n-1 [ i=n+3 n
      {dup index dup [ eq {pop (mark)} if exch} repeat
      pop] == flush
} bind def

/Pdict {%  dict
  count 0 eq {currentdict true} {dup type /dicttype ne {currentdict true}{false} ifelse}ifelse
  {(currentdict is being printed) ==} if
  dup length (Print dictionary, length =) exch 4 string cvs AppStr ==
 % {[3 1 roll]==} forall
  {
    [3 1 roll dup type (arraytype) eq {
       length [ (l=) 3 -1 roll]
    } if ]==
  } forall
} bind def

/Args {% stack ... /Comment Nargs Args
       % 0 1 2 3   /Test    3     Args
    [ 3 1 roll        % a1 ... aN [ /Cmnt N
      dup 2 add exch  % a1 ... aN [ /Cmnt N+2 N
      {dup index dup [ eq {pop (mark)} if exch} repeat pop % 2009!
    ] == flush
} bind def

% ========================================================= Colors (userdict)
product 0 5 getinterval (DView) eq not {%
%   /BlackWhite false def
%   statusdict % is the printer color printer? 
%   begin /processcolors where {pop processcolors}{-1} ifelse 
%   end 0 le /BlackWhite exch def

   /BlackWhite false def
   %  GSview is "color printer":
   product 0 3 getinterval (AFP) eq {/BlackWhite false def} if

   /BW.setrgbcolor /setrgbcolor load def
   BlackWhite {/setrgbcolor {pop pop pop 0 0 0 BW.setrgbcolor} bind def} if
} if

% systemdict /colorimage known {} {} ifelse


%  ----------------------------------- Standard 16         
/White   {1.  1.   1.  setrgbcolor} bind def
/Silver  {.75 .75  .75 setrgbcolor} bind def   
/Gray    {.50 .50  .50 setrgbcolor} bind def   
/Black   { 0   0    0  setrgbcolor} bind def
/Red     {1.   0    0  setrgbcolor} bind def
/Maroon  {.50  0    0  setrgbcolor} bind def
/Yellow  {1.  1.    0  setrgbcolor} bind def 
/Olive   {.50 .50   0  setrgbcolor} bind def
/Lime    { 0  1.    0  setrgbcolor} bind def   
/Green   { 0  .50   0  setrgbcolor} bind def
/Aqua    { 0  1.   1.  setrgbcolor} bind def              % /Cyan
/Teal    { 0  .50  .50 setrgbcolor} bind def   
/Blue    { 0   0   1.  setrgbcolor} bind def
/Navy    { 0   0   .50 setrgbcolor} bind def   
/Fuchsia {1.   0   1.  setrgbcolor} bind def   
/Purple  {.50  0   .50 setrgbcolor} bind def
%  ----------------------------------- Standard 16         

/Green2  { 0  .75   0  setrgbcolor} bind def

/Brown  {0.647 0.165 dup setrgbcolor} bind def   % 165 42 42
/Sienna {0.647 0.32  .17 setrgbcolor} bind def   % 165 82 45

/Gold  {1.  .84  0 setrgbcolor} bind def
/Orange{1. 0.647 0 setrgbcolor} bind def       % 255 165 0; DarkOrange: 255 140 0
/Red2   {Fuchsia} bind def       % keep for compatibility
% =================================== GenSec (dict) itself (userdict)

/GenSec <<

/MAX {2 copy lt {exch} if pop} bind %def
/MIN {2 copy gt {exch} if pop} bind %def
% compare to given precision
/eqp {% r1 r2 prec
   3 1 roll sub abs ge
} bind

/GetLast {% [array] ---> last element
    dup length 1 sub get
} bind

/forfor {% x0 xN Nf=N+eps ---> x0' step xN]   (N+1 elements, x0 is possibly updated (if eps>0), xN intact
   dup 4 2 roll                         % Nf Nf x0 xN
   exch 2 copy sub 4 -1 roll div dup    % Nf xN x0 step step
   0. eq {pop 1} if dup
   5 -1 roll dup floor sub 2 div        % xN x0 step step eps/2
   mul 3 -1 roll add                    % xN step x0'
   exch 3 -1 roll                       % x0' step xN 
} bind

/forforall {% x0 xN Nf=Ni+eps --> [x0' x1 ... xN']
            %  (N+1 elements; x0, xN updated if eps>0, intact otherwise
   [ exch dup 5 -2 roll                 % [ Nf Nf x0 xN
   exch 2 copy sub 4 -1 roll div        % [ Nf xN x0 step
   4 -1 roll dup floor dup cvi 6 1 roll % [ Ni xN x0 step Nf Ni
   sub dup 0. eq {                      % [ Ni xN x0 step eps
      pop
   }{
      1 index mul 2. div dup            % [ Ni xN x0 step dx dx
      4 -1 roll add exch                % [ Ni xN step x0' dx
      4 -1 roll exch sub exch 3 -1 roll % [ Ni xN' x0' step
   } ifelse
   dup 0. eq {%            ???  nado li ???
      pop pop exch pop
   } {
      4 -1 roll 1 sub {                    % [ xN' x0' step 
         2 copy add exch                   % [ xN' x0' x1 x2 x3 ... step
      } repeat pop counttomark -1 roll
   } ifelse
   ]
} bind 

% --------------------------------------------------------- Math (in GenSec)

/Upd180 {%  ang  --> update angle to (-Pi..Pi]
  {dup  180 le {exit} if 360 sub} loop
  {dup -180 gt {exit} if 360 add} loop
} bind

%/Sqrt0 {dup 0 le {pop 0}{sqrt} ifelse} bind 

/Atan180 {% sin cos
  1 index 0 lt {exch neg exch atan neg}{atan} ifelse
} bind
%   Return 0 as atan(0,0)
/Atan0 {2 copy 0 eq exch 0 eq and {/Atan0 2 Args pop}{Atan180} ifelse} bind 

/Atan90 {% y x --> arctan(y/x) in [-90,90]
  dup 0 eq
  {pop {-90}{0 (Atan90: 0/0) ==}{90} ArthIf exch pop}
  {2 copy mul 2 mul 3 1 roll dup mul exch dup mul sub atan Upd180 2 div} ifelse
} bind

/a2_b2 {% a  b   --> a^2-b^2
  2 copy sub 3 1 roll add mul
} bind

% ---------------------------------------------------------------
/Tan  {dup sin exch cos div} bind 
/Asin {dup dup mul 1 sub neg sqrt atan Upd180} bind 
/Acos {Asin 90 exch sub} bind 
/Exp {2.718281828 exch exp} bind 
%/Cosr {//Radian mul cos} bind 
%/Sinr {//Radian mul sin} bind 
/CubeRoot {dup abs 1. 3. div exp exch 0 lt {neg} if} bind 
% ---------------------------------------------------------------
/Signum {%    returns -1, or 0, or 1
    dup 0 lt {pop -1}{0 gt {1}{0} ifelse} ifelse
} bind

/XYadd {% x1 y1 x2 y2  --> x1+x2 y1+y2
  3 -1 roll add 3 1 roll add exch
} bind 

/XYsub {% x1 y1 x2 y2  --> x1-x2 y1-y2
  3 -1 roll sub neg 3 1 roll sub exch
} bind 

/XYmul {% x1 y1 x2 y2  --> (x1+I*y1)*(x2+I*y2)
   4 copy   3 -1 roll mul neg 3 1 roll mul add
   5 1 roll 4 -1 roll mul     3 1 roll mul add
} bind 

/XYdiv {% x1 y1 x2 y2  --> (x1+I*y1)/(x2+I*y2)
   2 copy dup mul exch dup mul add 5 1 roll neg XYmul
   2 index div 3 1 roll exch div exch
} bind 

/XYmod {% dx dy
   dup mul exch dup mul add sqrt
} bind

/XYpolar {% x y --> r  phi
   exch 2 copy dup mul exch dup mul add sqrt 3 1 roll
   2 index 0. eq {pop pop 0.} {Atan180} ifelse
} bind 

/FLT {% x y --> Mob(x,y)   // Mobius params in currentdict
%       z*z2 + z1           z1 = x1 + i*y0 = Rmob*cos(l0)-1 + i*Rmob*sin(l0)
%       ---------,  
%       z*z1 + z2           z2 = x2 + i*y0 = Rmob*cos(l0)+1 + i*Rmob*sin(l0)
%
   2 copy Xflt2 Yflt0 XYmul Xflt1 Yflt0 XYadd 4 2 roll
          Xflt1 Yflt0 XYmul Xflt2 Yflt0 XYadd XYdiv
} bind

/Polar {%   r phi --> x=r*cos  y=r*sin
  2 copy cos mul 3 1 roll sin mul
} bind

% --------------------------------------------- deprecated (XYpolar)
/ToPolar {% x y --> r  phi
   exch 2 copy dup mul exch dup mul add sqrt 3 1 roll
   2 index 0. eq {pop pop 0.} {Atan180} ifelse
} bind 

/ToPolar2 {% x1 y1 x2 y2 --> r  phi             % previous XY_Polar  
   3 -1 roll sub 3 1 roll sub neg exch XYpolar
} bind

/LocalXY {%    x1 y1  x2 y2  -> c mu x0 y0
%--------
 3 -1 roll 2 copy add 2 div 5 1 roll sub      % Y0 x1 x2 dy 
 3  1 roll 2 copy add 2 div 5 1 roll sub neg  % X0 Y0 dy dx 
 2 copy dup mul exch  dup mul add sqrt 2 div  % X0 Y0 dy dx c 
 5  1 roll Atan0 Upd180 3 1 roll              % c mu X0 Y0 
} bind

/LocalMX {% c Mu X0 Y0  ---> Matrix
          % Usage:
          % To local: X Y MX  transform --> x y; Tau-Mu --> tau_loc;  k*c --> knorm
          % Backward: x y MX itransform        ; tau+Mu            ;  kn/c
   neg exch neg exch matrix translate 3 1 roll     % .... tmatrix c mu
   neg matrix rotate exch                          % .... tmx rmx c
   1 exch div dup matrix scale                     %....  tmx rmx smx
   matrix concatmatrix matrix concatmatrix
} bind

/MinMax {%  [ X-array ] Minmax --> Xmin Xmax
  dup 0 get exch 2 copy
  { 2 copy gt {exch} if pop} forall 3 1 roll
  { 2 copy lt {exch} if pop} forall
} bind 

/MinMaxXY {%  [ X Y X Y ] --> X1 Y1 X2 Y2
  [[ true  4 -1 roll               % [ [ true [xy]
  {%                               % [ [ bool(f) q(x)
     exch not dup                  % [ [ q bool' bool'
     {exch counttomark 1 add 1 roll} if
  } forall pop ] MinMax            % [y y y X1 X2
  counttomark 1 add 2 roll] MinMax % X1 X2 Y1 Y2
  3 -1 roll exch
} bind 

/Solve2 {%   p  q  --> real_roots of x^2+px+q=0  true 
         %          or                           false
  exch -2. div 2 copy dup mul exch sub dup 0. lt {% q -p/2 D
    pop pop pop false                             % false  
  } {
    sqrt 1 index 0. lt {sub} {add} ifelse dup  % q x0 x0
    3 1 roll div 2 copy gt {exch} if true      % x1 x2 true
  } ifelse
} bind  

/Solve3 {%   a2 a1 a0  --> real_roots of x^3+a2*x^2+a1*x+a0: [x1 (x2) (x3)]
10 dict begin
  /a0 ED /a1 ED dup /a2 ED -3 div /xadd ED
  /p3 a2 xadd mul a1 add 3 div def           % p3 is p/3
  /s3 p3 abs sqrt def
  /q a0 xadd dup dup mul 2 mul a1 sub mul sub def
  /Q %a1 dup dup 27 div a2 dup mul 108 div sub mul mul
     %a0 dup 4 div a1 xadd mul 2 div add  xadd dup dup mul mul sub mul
     %add
     p3 dup dup mul mul q 2 div dup mul add
  def
  [
  Q 0 lt {
    p3 0 ge {Solve3_err1} if
    % cos(a)=A/B, a=-q, -B <= A <=B
    /a -2 p3 mul s3 mul q neg  % B A
       2 copy sub sqrt 3 1 roll add dup 0 lt  {(Solve3_err2)== abs} if sqrt
       Atan90 2 mul 3 div def     % a = alpha/3
       2 a cos mul    -2 a 60 sub cos mul    -2 a 60 add cos mul
  } {
     p3 0 gt { 
        2 s3 mul p3 mul abs q Atan90 2 div dup sin CubeRoot exch cos CubeRoot Atan90
        2 mul dup cos exch sin div -2 mul 
     } {
        % p3 < 0:   p3 0 eq {Err4} if 
        2 s3 mul p3 mul abs q div Asin % Not optimized for precision !!!
                                 2 div dup sin CubeRoot exch cos CubeRoot Atan90
        -2. exch 2 mul sin div 
     } ifelse
  } ifelse
  ] {} Sort [exch {s3 mul xadd add} forall]
end
} bind  


/SolveEQ {% proc x1 x2 eps_y --->  x true   or false
          % proc x1 x2 0.000 --->  x true   or false  // eps may be 0. 
  4 1 roll
  2 index 3 copy exec                % eps proc x1 x2 proc x1 y2
  3 1 roll exch exec                 % eps proc x1 x2 y2 y1
  2 copy mul 0. gt {
     exch 
     %/Bad_EQ_x1x2y1y2 4 Args 
     6 {pop} repeat false
  } {
     % make y increasing from x1 to x2 (with possibly x2<x1):
     exch
     2 copy gt {4 2 roll exch 4 2 roll exch} if      % eps proc t1 t2 y1 y2
     % loop                                                
     {                                               % eps proc t1 t2 y1 y2
       2 copy sub abs 6 index le {
          pop pop add 2 div 3 1 roll pop pop true exit % t0
       } if
       4 2 roll 2 copy add 2. div                     % eps proc y1 y2 t1 t2 t0
       3 copy eq exch 2 index eq or                   % eps proc y1 y2 t1 t2 t0 t2=t0||t1=t0
  %old:
  %    {7 {pop} repeat false exit} if  
  %new:
       {7 1 roll 6 {pop} repeat true exit} if  
       dup 6 index exec                               % eps proc y1 y2 t1 t2 t0 y0
       dup 0 gt {                                     % |
          6 -2 roll pop                               % eps proc t1 t2 t0 y0 y1
          4 -1 roll pop exch                          % eps proc t1 t0 y1 y0
       } {
          6 3 roll pop exch pop                       % eps proc t2 t0 y0 y2
          4 2 roll exch 4 2 roll                      % eps proc t0 t2 y0 y2
       } ifelse
     } loop
  } ifelse
} bind

% --------------------------------------------------------- Markers (in GenSec)

/Dotted {%  L = distance between circles in Radii  *---*--- ...
         %  L = 0  --- un_dot
   dup 0 le {[] 0 0}{[ 0 3 -1 roll currentlinewidth mul] 0 1} ifelse 
   setlinecap setdash 
} bind 

/Spoint {%  Squared point at currentpoint 
  gsave currentpoint newpath translate
        dup abs dup dup scale currentlinewidth exch div setlinewidth 0 setlinecap
%        0 lt {0 setlinewidth -.5 dup 1 1 rectstroke}{1 setlinewidth -.5 0 moveto 1 0 rlineto stroke} ifelse
        0 gt {-.5 dup 1 1 rectstroke}{-.5 0 moveto 1 0 rlineto stroke} ifelse
  grestore
} bind 

/Spoint45 {%  R  // rotated square
  gsave currentpoint newpath translate dup scale 0 setlinecap 1 setlinewidth
        .3535534 dup neg dup moveto dup lineto stroke
  grestore
} bind 

/Rpoint {%  Radius  (R<0 --- fill with white)  (curr.point) 
    gsave currentpoint newpath [] 0 setdash translate dup 0 ge 
%      {PicLW 1 setlinecap 0 0 moveto 0 0 rlineto}
%      {-2 div PicDict /PicScal get div 0 0 3 -1 roll 0 360 arc closepath clip 
      {setlinewidth 1 setlinecap 0 0 moveto 0 0 rlineto}
      {-2 div 0 0 3 -1 roll 0 360 arc closepath clip 
             gsave 1 setgray fill grestore
      } ifelse stroke
    grestore
} bind 

/Across {% R Ang
  gsave currentpoint translate newpath [] 0 setdash  
     rotate
     dup dup scale  currentlinewidth exch div setlinewidth
     -1 0 moveto 1 0 lineto 0 -1 moveto 0 1 lineto stroke                   
  grestore     
} bind 

/Rcross {% R >< 0
%  Picmm
  gsave currentpoint translate newpath [] 0 setdash 0 setlinecap
     dup 0 lt {45 rotate abs} if
     dup dup scale  currentlinewidth exch div setlinewidth
%      dup scale
     -1 0 moveto 1 0 lineto 0 -1 moveto 0 1 lineto stroke                   
  grestore     
} bind 

% --------------------------------------------------------- Arrows (in GenSec)
/ArrowDict << 
   /Lback 2  /Lforw 6  /Lwid 3 
   /ArrowType 2    % 0: no arrow; 1: normal arrow: 2: curvilinear arrow (Moebius)
%  /ArrowCrv  0    % basic curvature (for Moebius)   
>> 

/ArrowSet {% [Lback Lforw Lwid]
           % [] to set defaults
  dup length  3  ne {pop [2 6 3]} if   % [Lb Lf Lw]
  ArrowDict begin aload pop          % Lb Lf Lw
   /Lwid ED /Lforw ED  /Lback ED
  end
} bind

/ArrowScale { % scale_factor
  ArrowDict begin
    [Lback Lforw Lwid] ArrowSet
    dup Lwid mul /Lwid ED dup Lforw mul /Lforw ED Lback mul /Lback ED   end
} bind

/ArrowHead {% (curr.pt.context) Lback Lforw Lwid dir
%                                2  6  3  
%     draw arrow head from current point in given direction 

%  gsave Red 3 PicLW currentpoint newpath moveto 3 copy exch pop Polar rlineto 5 Rpoint stroke grestore
%  ArrowDict Pdict

  gsave currentpoint newpath 0 setlinecap 0 setlinejoin
    translate 
       rotate
       0 0 moveto                                      % Lback Lforw Lwid
       3 -1 roll neg exch 2 copy lineto                % Lforw -Lback Lwid
       3 -1 roll 0 lineto                              % -Lback Lwid
       neg lineto closepath fill
  grestore
} bind

/ArrowHeadCrv {% (curr.pt.) x2 y2 k
%                               
%     draw curved arrow head from current point to given direction 

   ArrowDict begin
     Lforw currentlinewidth mul
     Lback currentlinewidth mul
     Lwid  currentlinewidth mul
   end
   8 dict begin
   /lw ED /lb ED /lf ED /k ED 2 copy 2 copy

   gsave currentpoint newpath  0 setlinecap 0 setlinejoin 
       XYsub            % x2 y2 x2 y2 x2-x1 y2-y1
       4 2 roll translate
       exch atan rotate
        lf 2 div k mul Radian mul rotate        
%		  lf 2 div k mul Asin  rotate
%		  lf 2 div k mul abs dup 1 le {pop}{lf exch div /lf ED} ifelse
		  /ll lf lb add def
		  k lf mul //Radian mul dup cos /e1 exch def sin /e2 exch def % exp(ikL)= e1+i*e2
          k abs .001 lt {0 lf neg} {1 e1 sub k div e2 neg k div } ifelse /f2 ED /f1 ED 
                                                  		  %  (1-exp(ikL))/k = f1+i*f2   
	      /Mob {%                                     % x y   
%		  /IN 2 Args
		       2 copy f1 f2 XYmul 0 2 XYmul 4 2 roll % numerator z
			   1 e1 sub e2 neg XYmul 1 e1 add lf mul e2 lf mul XYadd XYdiv
%		  /OUT 2 Args	   
		  } bind def
          0 0 moveto
		  0               0 
		  ll neg   lw neg
		  lf neg          0 
		  ll neg   lw
          0               0
          4 {% p1 p2
%               gsave Green 4 copy moveto lineto stroke grestore
			   3 index 3 index 2 copy Mob 6 2 roll
               XYadd 2 div exch 2 div exch Mob 4 2 roll
%               gsave Blue 3 Rpoint 4 copy moveto 3 Rpoint moveto 3 Rpoint grestore
			   Arc3 pop			   
          } repeat 	pop pop
          fill %stroke		  
%         2 0 Mob moveto 10 Rpoint 10 0 Mob moveto 10 Rpoint
	   end
%	 gsave 1 PicLW Green 0 0 moveto 3 Rpoint 1 0 rlineto 0 0 moveto 0 .5 rlineto  stroke grestore
  grestore
   moveto  %  set current point, expected by user
} bind


/rl^ {% dx dy [optional_arrow_descr] :  rlineto-arrow
%                                          2  6  3  
  dup type /arraytype ne {ArrowDict begin Lback Lforw Lwid end}
                         {aload pop} ifelse          % dx dy Lback Lforw Lwid
  3 {currentlinewidth mul 5 1 roll} repeat           % Lback Lforw Lwid dx dy
  gsave 2 copy rmoveto currentpoint 7 2 roll grestore% x y Lback Lforw Lwid dx dy
  exch 2 copy dup mul exch dup mul add sqrt          % x y Lback Lforw Lwid dy dx dl
  3 1 roll atan exch                                 % x y Lback Lforw Lwid fi dl 
              % commented 14.08.2018
  3 index sub % dup 0 lt {pop 0} if                    % x y Lback Lforw Lwid fi dl'
  1 index 2 copy cos mul 3 1 roll sin mul rlineto    % x y Lback Lforw Lwid fi       
      ArrowHead 
  moveto   % restore user_expected current point
} bind

/l^ %%%% def   lineto-arrow
{%
   	currentpoint 3 -1 roll sub neg 
        3 1 roll sub exch rl^
} bind

/arc^ {% x0 y0 r phi1 phi2
    gsave 5 copy arc currentpoint 7 2 roll newpath  % xend yend x0 y0 r phi1 phi2
    grestore 
    1. 3 index abs div dup 7 1 roll                 % xend yend k x0 y0 r phi1 phi2 k
    ArrowDict /Lforw get mul currentlinewidth mul
    //Radian mul sub arc                            % xend yend k
    ArrowDict /ArrowType get 2 eq{%
        ArrowHeadCrv      
    }{%
        pop l^
    } ifelse
} bind

/arcn^ { %def  arc-arrow
    gsave 5 copy arcn currentpoint 7 2 roll grestore % xend yend x0 y0 r phi1 phi2
%	2 copy le {360 sub} if
    -1. 3 index abs div dup 7 1 roll                 % xend yend k x0 y0 r phi1 phi2 k (<0)
    ArrowDict /Lforw get mul currentlinewidth mul
    //Radian mul sub arcn                            % xend yend k
    ArrowDict /ArrowType get 2 eq{%
        ArrowHeadCrv      
    }{%
        pop l^
    } ifelse
} bind

/arc^^ {% x0 y0 R fi1 fi2              arrow-arc-arrow
    2 copy add 2 div 3 1 roll sub abs 2 div  % x0 y0 R fi0 |dfi|
    5 copy 
    gsave newpath 1 index add     arc^  stroke grestore
    gsave newpath 1 index sub neg arcn^ stroke grestore
} bind

/crv^ {%  (curr.pt.context) x1 y1 x2 y2 x3 y3  curveto_arrow
3 {currentpoint 8 -2 roll 3 -1 roll sub 3 1 roll sub neg exch} repeat rcrv^
} bind

/rcrv^ {% rcurveto_arrow:  (curr.pt.context) x1 y1 x2 y2 x3 y3
%
% k(1)=-18L1L2sin(a-b)+24cL1sin(a-2b)+24c^2sin(2b)-6L1^2sin(2a-2b)-40cL2sin(b))/(3L2^3)
% gs/dt(1) = 3L2
%
 2 copy currentpoint 10 4 roll 4 copy   % p3 p0 p1 p2 p3 p2 p3 
 3 -1 roll sub 3 1 roll sub neg exch    % p3 p0 p1 p2 p3 p3-p2
 dup mul exch dup mul add sqrt 3. mul   % p3 p0 p1 p2 p3 3|p3-p2|
 dup 0. eq {(Singular EndPoint) ==} if  % p3 p0 p1 p2 p3 3|p3-p2|
 ArrowDict /Lforw get                                                 %???
 currentlinewidth mul exch div          % p3 p0 p1 p2 p3  dt         %???   
 dup 1. gt                                                           %???
 %{9 {pop} repeat rl^ }              %   just rl^ to end pt
 {pop rcurveto pop pop pop pop}      %   just rcurveto to end pt
 {dup neg 1. add dup 2 copy mul dup %   ... dt t1=(1-dt) t1 t1^2 t1^2
  dup 3 index mul dup                       6 {8 -1 roll mul 7 1 roll} repeat
  dup 2 mul dup                 2 {7 index mul 6 -1 roll add 5 1 roll} repeat
  dup 2 {4 index 7 index 2 index mul sub mul 3 mul 3 -1 roll add exch} repeat
  rcurveto  3 -1 roll add 3 1 roll add exch l^
 } ifelse
} bind

% --------------------------------------------------------- Drawing (in GenSec)

/XYdraw {% draw array [x y x y ...]  or --mark-- x y x y ...
   dup type /arraytype eq 
   {aload length}
   {counttomark dup 2 add -1 roll pop} ifelse 
   dup 0 eq {pop}{
      2 idiv 1 sub 3 1 roll moveto {lineto} repeat
   } ifelse
} bind 

%/XYdrawPt {% draw array [x y x y ...]  or --mark-- x y x y ...
%   dup type /arraytype eq 
%   {aload length}
%   {counttomark dup 2 add -1 roll pop} ifelse  
%   2 idiv {moveto 1 ???LWPoint} repeat
%} bind 

/text_wh  %% (text) text_wh   --> width height
{ gsave currentpoint translate
    newpath 0 0 moveto false charpath flattenpath pathbbox  % ->  0 0 wx wy 
    4 2 roll pop pop     % -> wx wy       
  grestore 
} bind 

/set_text { %% (text) Cx Cy set_text  show !!!
                %                       -> Cy=1.5
                %    +---------------+  -> Cy=1. 
                %    |TextBoundingBox|  -> Cy=0.5 
                %    +-------+-------+  -> Cy=0.
                %    |       |       |  -> Cy=-0.5 (-0.7)
                % Cx=0.     0.5      1. 
                %    Arrange specified point of (text+margins)Bbox 
                %    to current_point
                % f.e., centering is (text) 0.5  0.5  Arrange_text
  gsave currentpoint translate
    2 index text_wh  % extr. text to get its size % -> (text) Cx Cy wx wy
    newpath
    dup 5 div dup        % -> (text) Cx Cx d  d
    6 1 roll 2 mul dup
    3 1 roll add       3 1 roll add
    3 1 roll mul       3 1 roll mul
    2 index sub neg
    3 1 roll sub
  grestore rmoveto
} bind 

%  Apply set_text to firsrt char only
/set_text1 {  %% (text1) Cx Cy set_text1
   2 index 0 1 getinterval 3 1 roll set_text pop 
} bind 

/Aset_text  %% (curr.pt) % (text) Angle AddShift  Aset_text  show !!!
{ gsave currentpoint translate
    2 index text_wh  % extr. text to get its size % -> (text) A Sh wx wy
    newpath
    2 div exch 2 div 2 copy mul sqrt 2 div dup % (t) A Sh wy wx dxy dxy
    2 index add exch 3 index add               % (t) A Sh wy wx a b
    2 copy mul 3 1 roll                        % (t) A Sh wy wx ab a b
    6 index cos mul dup mul exch    
    6 index sin mul dup mul add sqrt div       % (t) A Sh wy wx Rpolar
    4 -1 roll 1 add mul                        % (t) A wy wx  RpolarSh
    4 -1 roll Polar                            % (t) wy wx  dx dy
    4 -1 roll sub 3 1 roll sub neg exch        %  (t) x y   
  grestore rmoveto 
} bind 

/Tclean {%  |curr. pt| (text) optional_W  --> text_unchanged
   dup type /stringtype eq {.15} if exch          % .15 (text)
   gsave 1 setgray dup 3 1 roll                   % (text) .15 (text)  
      text_wh currentpoint translate 2 copy scale % (text) .15 w h
      %Yellow
      exch div exch neg dup 3 -1 roll mul exch    % (text) x1 (eg, -.11) y1 (eg, -0.2)
      1 index -2 mul 1 add 1 index -2 mul 1 add %/Rect 4 Args 
      rectfill
   grestore
} bind 

/Ishow  {%   (r123) Ishow  : Prints 2-nd and next characters as index
   dup 0 1 getinterval search {%           % (rest) (1st) () true
     pop show dup stringwidth pop .6 mul   % (rest) dx
     currentpoint 4 1 roll add 3 1 roll    % xn yn (rest)
     gsave
       0 currentfont /ScaleMatrix   %  known ... etc
       get 0 get -.15 mul rmoveto currentpoint translate 
       0.666 dup scale  0 0 moveto show 
     grestore moveto 
    } if
} bind

/Pshow  {%   (r123) Pshow  : Prints 2-nd and next characters as power
   dup 0 1 getinterval search {%           % (rest) (1st) () true
     pop show dup stringwidth pop .6 mul   % (rest) dx
     currentpoint 4 1 roll add 3 1 roll    % xn yn (rest)
     gsave
       0 currentfont /ScaleMatrix   %  known ... etc
       get 0 get .55 mul rmoveto currentpoint translate 
       0.666 dup scale  0 0 moveto show 
     grestore moveto 
    } if
} bind 

%  Tilde show
/Tshow {%  (char)
  gsave currentpoint translate
    dup text_wh exch 2 div exch  % (c) wx/2 wy
    moveto 
    (\176) .5 0.3 set_text show  % "similar" symbol 
  grestore
  show
} bind 

%  Bar show
/Bshow {%  (char)
  gsave currentpoint translate
    dup text_wh exch 2 div exch  % (c) wx/2 wy
    moveto 
    (-) .5 0.3 set_text show  % "minus" symbol, \055
  grestore
  show
} bind 
     
/IPshow  {%   (Main) (Ind) (Pow) IPshow  : Prints index and power near Main: Main_{Ind}^{Pow}
          %   (no font changes for the moment)
   3 -1 roll
   % dup length ... 
   show currentpoint                         % I P x y
   gsave
       2 copy translate .6 dup scale
       currentfont /ScaleMatrix   %  known ... etc
       get 0 get dup                         % I P x y S S
       -.2 mul 0 exch rmoveto               % I P x y S
       5 -1 roll show currentpoint pop exch  % P x y dx1 S 
       0 0 moveto 
       0.66 mul 0 exch rmoveto               % P x y dx1
       4 -1 roll show currentpoint pop MAX   % x y dx
       .6 mul 3 -1 roll add exch
   grestore moveto 
} bind 

/SHOW {%  _subscript ^superscript | normalsize $math$
7 dict begin
gsave
currentpoint /ybas exch def /xbas exch def
/mx matrix currentmatrix def
/cf currentfont def
/sf currentfont /ScaleMatrix   %  known ... etc
                               get 0 get def
/small false def
/math false def
dup length {dup} repeat length 1 sub 0 1 3 -1 roll
{1 getinterval
dup (^) eq
 {pop small
      {mx setmatrix xbas ybas moveto}
      {/xbas currentpoint pop def
       /small true def
      } ifelse
      0 .55 sf mul rmoveto 0.7 dup scale
 }
 { dup (_) eq
   {pop small
      {mx setmatrix xbas ybas moveto}
      {/xbas currentpoint pop def
       /small true def
      } ifelse
       0 sf -0.15 mul rmoveto 0.7 dup scale
   }
   { dup (|) eq
     {pop mx setmatrix currentpoint pop ybas moveto /small false def}
     { dup ($) eq
       {pop math {cf} {/Symbol findfont sf scalefont} ifelse setfont
        /math math not def
       }
       {%gsave 1 0 0 setrgbcolor currentpoint moveto 0 sf rlineto stroke grestore
       show} ifelse
     } ifelse
   } ifelse
 } ifelse
%gsave 0 1 0 setrgbcolor 1 setlinecap xbas ybas moveto 0 0 rlineto stroke grestore
%Anykey
} for
currentpoint
grestore
moveto
end
} 

/Defformat {%  x ---> number_of_decimal_digits after decimal point
  10 string cvs (.) search
  {pop pop length} {pop 0} ifelse
} bind 


/I_format {%   |value|  -->  string
%/I_f 1 Args
    dup dup 0 gt {log cvi} if  1 add string cvs
%/Ires 1 Args
} bind 

/F_format {%   rm_000 |v| prec
%/F_f 3 Args
    dup 3 1 roll 10. exch exp mul round cvi   % rm_000 prec I=1000*v
    I_format                                  % rm_000 prec (1234000)
    dup length 2 index sub                    % rm_000 prec (1234000) len-prec
    %  convert 0.0032 to (00032)
    dup 0 le {1 exch sub () exch {(0) AppStr} repeat exch AppStr}{pop} ifelse
%    dup (0) eq {1 index {(0) AppStr} repeat} if
       dup length 3 -1 roll 3 copy            % rm (...) l prec  (...) l prec
       sub 0 exch getinterval                 % rm (...) l prec  (str1)
       5 1 roll                               % (str1) rm (...) l prec
       dup 3 1 roll sub exch getinterval      % (str1) rm (str2)
       % remove trailing zeros
       exch {
          [ exch {} forall counttomark {dup 48 eq {pop}{exit} ifelse} repeat
          ] dup length string 0 2 copy 5 -1 roll % str 0 str 0 [...]
          {put 1 add 2 copy} forall pop pop pop
          dup length 0 gt {(.) exch AppStr} if  % (str1) rm (.str2) 
       } {
          (.) exch AppStr                        % (str1) rm (.str2) 
       } ifelse                                  %  (str1.) (str2)
       AppStr
%/Fres 1 Args
} bind 

%       USE  (\261) FOR MINUS SIGN ?  NO!!!
/Format {%   value frmt_mode optional_(D)_for_degrees --->  string
      % frmt_mode  is [-]l.d (-9.1) or [-]91
      % f.e. -123.4775 2  Format --->  (-123.48)
      %      -123.4775 0  Format --->  (-123)
      %       123.4775 12.0  Format --->  (        -123)

      % mode < 0 --- keep trailing zeros
      % f.e.  3.4000  2  Format --->  (3.4)
      %       3.4000 -2  Format --->  (3.40)
   dup (D) eq {pop true}{false} ifelse 3 1 roll
%/Format 3 Args
   dup type /realtype eq {%
     %                convert 0 to 0.0:
     10 mul round cvi exch cvr exch
   } if                                           % bool_deg v mode
   exch dup 0 lt {%
      neg
      currentfont begin FontName end /Symbol eq pop true %
      {(\055)}{(\261)} ifelse
   } {()} ifelse 3 1 roll                         % deg (sign) mode |v|
   dup type /integertype eq {%
      exch 3 1 roll                               % deg n (s) |v|   
      I_format                                    % deg n (s) (v)
   } {%
      % real                                      % deg (sign) mode |v|
      exch
      dup 0 lt {abs true}{false} ifelse 3 1 roll  % deg (s) rm_000 |v| mode 
      abs dup 10 idiv 5 1 roll                    % deg n (s) rm_000 |v| |mode|
      10 mod F_format
   } ifelse                                       % deg n (s) (formatted)
   AppStr
   dup length 3 -1 roll                           % deg (frm) l n
%/F_len_req 3 Args
   2 copy lt {
      % length less than required:  
      exch sub ( ) exch 1 sub {( ) AppStr} repeat % deg (frm) (   )
      exch AppStr
   } {pop pop} ifelse
   exch {(\260) AppStr} if
%/RES 1 Args
} bind 


%       USE  (\261) FOR MINUS SIGN !!!
/OldFormat {%   value +-n_dec.digits  Format --->  string
      % f.e. -123.4775 2  Format --->  (-123.48)
      %      -123.4775 0  Format --->  (-123)

      % n < 0 --- keep trailing zeros
      % f.e.  3.4000  2  Format --->  (3.4)
      %       3.4000 -2  Format --->  (3.40)
   dup mark 4 2 roll abs exch dup 0 lt {   % n [ |n| v bool
    currentfont begin FontName end /Symbol eq %
      {(\055)}{(\261)} ifelse 3 1 roll  
   } if                                    % n [ (-?) |n| v            
    abs 10 2 index exp mul cvi             % n [ () |n| I=|v|*10^|n| 
    12 string cvs dup length               % n [ () |n| (III) l
    3 -1 roll sub                          % n [ () (III) l-n
    dup 0 le
    { (0.) exch neg {(0) AppStr} repeat    % n [ () (III) (0.00)
       exch}                               % n [ () (0.00) (III)
    {1 index 0 3 -1 roll getinterval       % n [ () (II)=(entfrac) (ent)
     anchorsearch                          % n [ () (frac) (ent) true
     not {(???)} if (.) AppStr exch        % n [ () (ent.) (frac) 
    } ifelse 
    counttomark 1 sub {AppStr} repeat      % n [ (-ent.frac) 
    3 1 roll pop
     0 gt {%       remove trailing zeros
%(Remove) == Pstack
           dup 0 exch                      % [ ()  (ent.) (frac) nz (frac)  --- count end-zeros
           {48 eq {1 add}{pop 0} ifelse} forall   %   ....(frac) nz
           1 index length exch sub 0 exch  % [ ()  (ent.) (frac) 0 l1
           getinterval                     % [ ()  (ent.) (frac) 
       } if
} bind 

/RectLine {% x1 x2 y1 y2  a b c  (line is ax+by=c) -->                     false
                                                %  --> xmin xmax true  p q true
9 dict begin                                    %  --> ymin ymax false p q true
%/Rect 7 Args
   /c ED /b ED /a ED  2 copy gt {exch} if /y2 ED /y1 ED 2 copy gt {exch} if /x2 ED /x1 ED
   /hor a abs b abs le def
   a 0. ne b 0. ne and {%                                   %  2----3
      hor {a b c b}{b a c a} ifelse div /q exch def div neg /p exch def
      [a x1 mul b y1 mul add c sub                          %  |    |  
       a x2 mul b y1 mul add c sub                          %  1----4
       a x2 mul b y2 mul add c sub                          %
       a x1 mul b y2 mul add c sub  3 index %/F4321 4 Args  % [ F1 F4 F3 F2 F1
       1 index mul 0. le {x1 hor not {a mul c exch sub b div} if 5 1 roll} if % [ ? 1 4 3 2 
       1 index mul 0. le {y2 hor     {b mul c exch sub a div} if 4 1 roll} if 
       1 index mul 0. le {x2 hor not {a mul c exch sub b div} if 3 1 roll} if 
               mul 0. le {y1 hor     {b mul c exch sub a div} if         } if  % [ ? ?   
       counttomark 2 ge {] MinMax p q hor true   %/RectT 3 Args
                        }{] pop           false  %/RectF 1 Args
                        } ifelse
   } { 
      a 0. ne {%     b = 0, vertical
            c a div dup /q ED dup x2 le exch x1 ge and dup {y1 y2 0. q false 6 -1 roll} if
      } { 
         b 0. ne {%  a = 0
            c b div dup /q ED dup y2 le exch y1 ge and dup {x1 x2 0. q true   6 -1 roll} if
         } {false} ifelse 
      } ifelse
   } ifelse
 end
 % updated version:
 {3 1 roll true}{false} ifelse
%   dup {/RectT 6 Args} {/RectF 1 Args} ifelse
} bind

%----------------------------------------------------------------------------  Arcs
/_Arc0 {%  (curr.pt) if_arrow tau length  --> new_Tau (= tau)
   %/_Arc0: 3 Args
    2 copy exch Polar 3 -1 roll                   % if_arr tau dx dy len   
    0. ge
    {4 -1 roll  {rl^} {rlineto} ifelse}           % tau
    {% line through infinity
     currentpoint 3 -1 roll add 3 1 roll add exch % if_arr tau xdest ydest
     KdrawLength 3 index Polar 2 copy rlineto     % if_arr tau xdest ydest DX DY
     -2 mul exch -2 mul exch rmoveto              % if_arr tau xdest ydest  
     4 -1 roll  {l^} {lineto} ifelse
    } ifelse  
} bind 

/_Arc90 {%  (curr.pt) tau k rot_or_length(if k=0) arrow  --> new_Tau
   %/Arc90: 4 Args
   % rotation =< 90, sign correct
    4 1 roll
    1 index 0. eq                             % arr tau k rot/s  k=0 
    {exch pop _Arc0} 
    {                                         % arr tau k rot  
     %(tau k r) == pstack
     dup 3 index add 4 1 roll                 % arr tau k rot  
     2 div dup 3 index add 3 1 roll           % arr tau' tau mu k r/2
     dup 3 1 roll sin exch div abs 2 mul      % arr tau' tau mu r/2 2c
     dup 4 -1 roll Polar 5 2 roll              % arr tau' x3 y3 tau r/2 2c 
     exch cos 1 add 3 mul div 2 mul dup        % arr tau' x3 y3 tau p p (p=4c/3/(1+cos))
     3 -1 roll Polar 5 2 roll                  % arr tau' x1 y1 x3 y3 p 
     5 index 180 sub Polar                     % arr tau' x1 y1 x3 y3 dx2 dy2 
     2 index add 4 1 roll                      % arr tau' x1 y1 y2  x3 y3 dx2   
     2 index add 4 1 roll                      % arr tau' x1 y1 x2 y2 x3 y3
     8 -1 roll {rcrv^} {rcurveto} ifelse
    } ifelse
    %(Arc90 OK) ==
} bind 

/_Arc {%  (curr.pt) bool_arrow tau k len/rot --> new Tau
   %/_Arc 4 Args
   1 index 0. eq 
   {exch pop _Arc0}
   { % update sign of rotation  
     2 copy mul 0. lt {neg} if                         % bool tau k rot
     dup abs 90 div ceiling dup cvi 3 1 roll div exch  % bool tau k rot/N N 
     1 sub
     {                                                 % bool tau  k d_rot  
        3 copy false _Arc90 4 -1 roll pop 3 1 roll     % bool tau' k d_rot
     } repeat 
     4 -1 roll _Arc90
   } ifelse 
   %(Arc OK) == %pstack
} bind 

/_ArcTo {%  (curr.pt) tau xdest ydest --> tau k len/rot
     currentpoint 4 2 roll LocalXY pop pop              % tau c mu
     %  k = sin(mu-tau)/c
     2 index sub Upd180 dup sin dup 0. eq               % tau c tau-mu sin(t-m) k=0
     3 index 0. eq  or                                  % ..... k=0_or_c=0                   
     {pop abs 179 gt {neg} if 0. exch}                  % tau 0. l=+-c
     {3 -1 roll div exch} ifelse 2. mul                 % tau k l/rot
} bind  
  
/Arc {%  (curr.pt) tau k len/rot --> new_Tau
   false 4 1 roll _Arc
} bind 

/Arc^ {%  (curr.pt) tau k len/rot --> new_Tau
   1 index 0. eq 
   {exch pop true 3 1 roll   _Arc0}
   {%
     gsave   
       3 copy Arc pop currentpoint 5 2 roll 
     grestore %/EPtkr 5 Args 
     2 copy ArrowDict /Lforw get 2 index mul abs       % xe ye tau k rot k rot |L*k|
     currentlinewidth mul //Radian mul exch            % xe ye tau k rot k rot_arr rot
     abs 1 index sub 0 lt {%                           % xe ye tau k rot k dr   
     	 pop pop Arc
     }{%                                               % xe ye tau k rot k dr
        2 index 0 gt {neg} if
        1 index 6 3 roll 4 index add Arc               % xe ye k dr k tau'
        3 1 roll exch                                  % xe ye k tau' k dr
        gsave 
%            gsave currentpoint newpath moveto Green 4 PicLW 3 copy Arc pop stroke grestore
           Arc currentpoint 
        grestore 4 -1 roll                            % xe ye taunew xnew ynew k
        ArrowDict /ArrowType get 2 eq{%
          ArrowHeadCrv      
        }{%
           pop l^
        } ifelse
     } ifelse
     3 1 roll moveto
   } ifelse  
} bind

/_Arc3 {%  (curr.pt) x1 y1 x2 y2 --> tau x2 y2 
%   gsave 4 copy moveto 3 Rpoint moveto 3 Rpoint grestore 

   2 copy currentpoint XYsub exch atan 5 1 roll % mu0 x1 y1 x2 y2
   4 copy XYsub neg exch neg      atan 5 1 roll % mu0 mu2 x1 y1 x2 y2
   6 2 roll currentpoint XYsub exch atan        % x2 y2 mu0 mu2 mu1
   exch sub add 3 1 roll
} bind 

/Arc3 {%  (curr.pt) x1 y1 x2 y2
    _Arc3 _ArcTo Arc
} bind 

/Arc3^ {%  (curr.pt) x1 y1 x2 y2
   _Arc3 _ArcTo Arc^
} bind 

/Crv123 {%  x0 y0 x1 y1 x2 y2 --> tau1 crv
   4 copy 4 2 roll XYsub exch Atan180   % x0 y0 x1 y1 x2 y2 mu2
   7 1 roll 6 2 roll                    % mu2 x2 y2 x0 y0 x1 y1
   3 index 3 index XYsub exch Atan180   % mu2 x2 y2 x0 y0 mu1
   6 -1 roll 1 index sub Upd180         % x2 y2 x0 y0 mu1 rot
   dup sin 7 3 roll                     % mu1 rot sinr x2 y2 x0 y0
   XYsub 2 copy exch Atan180            % mu1 rot sinr dx dy mu
   6 1 roll dup mul exch dup mul add    % mu mu1 rot sinr hh
   sqrt 2. div div 4 1 roll             % crv mu mu1 rot
   1 index add add exch sub
   exch
} bind def

%------------------------------------------------------- KKlib
%   [ x0 y0 tau k rot_or_len par ...]
%-------------------------------------------------------------

/Kload {%  [x y t k ...]  N_to_keep  --> x y t ... (Poss. nulls added)
         exch aload length dup 2 add -1 roll
         sub dup 0 ge {{pop}} {neg {null}} ifelse repeat
} bind 

/Qdef {% [x1 y1 t1 k1 ...] [x2 y2 t2 k2 ...]  --> Q
  4 Kload 5 -1 roll 4 Kload             % x2 y2 t2 k2 x1 y1 t1 k1   
  4 2 roll 8 -2 roll                    % t2 k2 t1 k1 x1 y1 x2 y2
   LocalXY pop pop                      % t2 k2 t1 k1 c mu
   dup 7 -1 roll sub neg exch           % k2 t1 k1 c beta mu
   5 -1 roll sub neg 2 copy add 2 div   % k2 k1 c be al omg
   sin dup mul 6 1 roll 2 index         % so^2 k2 k1 c be al c
   5 -1 roll mul exch sin add           % so^2 k2 c be kn1+sin(a)
   4  1 roll sin neg 3 1 roll mul add   % so^2 kn1+sin(a) kn2-sin(b)
   mul add
   % To get exactly  0. or  1.  ---
   % 8192. mul round 8192. div
} bind

/_Kdraw {% [x y t k l/rho ...]  ---> (curr_pt) t k l/rh
         % Prepare curr. point and args for Arc or Arc^
  5 Kload 5 -2 roll moveto                      % t k len/rho
  %  allow l/rh=0/null
  dup dup null eq exch 0. eq or 
  { % to be corrected
    pop dup 0. eq {KdrawLength} {360} ifelse    % t k l/rh  
  } if
} bind

/Kdraw {% [x y t k l/rho ...]
   _Kdraw Arc pop
} bind

/Kdraw^ {% [x y t k l/rho ...]
   _Kdraw Arc^ pop
} bind

/Kdraw^^ {% [x y t k l/rho ...]
   gsave newpath dup _Kdraw 2. div Arc^ pop grestore
   Kdraw 
} bind

/KdrawS {%   [x y tau k] S
         %   [x y tau k1 any S]
  dup type /arraytype eq {dup 5 get} if
  exch 4 Kload 4 2 roll moveto                                  % S tau k
  2 index 0 lt {neg 3 1 roll 180 sub 3 1 roll neg 3 1 roll} if  % S>=0 tau k
  2 index 0. eq {
     pop pop pop
  } {                                                           % S>0 tau k   
     dup 0. eq {
        pop Polar rlineto
     } {                                                        % S>0 tau k   
        3 -1 roll 1 index mul Radian mul abs                    % tau k rho
        dup 360. gt {
          3 copy pop 360 Arc pop                                % tau k rho>360    
          360. div dup floor sub 360. mul
        } if Arc pop
     } ifelse
  } ifelse   
} bind

/KdrawS^ {%   [x y tau k] S
          %   [x y tau k1 any S]
  dup type /arraytype eq {dup 5 get} if
  exch 4 Kload 4 2 roll moveto                                  % S tau k
  2 index 0 lt {neg 3 1 roll 180 sub 3 1 roll neg 3 1 roll} if  % S>=0 tau k
  2 index 0. eq {
     pop pop pop
  } {                                                           % S>0 tau k   
     dup 0. eq {
        pop Polar rl^
     } {                                                        % S>0 tau k   
        3 -1 roll 1 index mul Radian mul abs                    % tau k rho
        dup 360. gt {
          3 copy pop 360 Arc pop                                % tau k rho>360    
          360. div dup floor sub 360. mul
        } if Arc^ pop
     } ifelse
  } ifelse   
} bind

/Ksplit {% [K0]  S  N    S0 -> [K0] [K1] .. [KN]
         %      dS  N=0: S0  360 deg case;            (xN,yN)=(x0,y0) 
         %     any  N<0: S0  360 deg case, |N| parts; (xN,yN)=(x0,y0)   
         %
%/Ksplit 4 Args
9 dict begin
  /S0 ED 
  3 -1 roll 4 Kload /k ED /tau0 ED /y0 ED /x0 ED % S N
  dup 1 lt k 0. ne and dup /case360 ED {%
     /S360 2 Pi mul k div abs def
     dup 0 eq {pop S360 exch div .5 add round cvi}{abs exch pop} ifelse
     S360 exch                 % S N  (>=2)
   } if
   dup 1 le {pop 2} if                           % S N  (>=2)
   dup /N ED div /dS ED
   [x0 y0 tau0 k S0]
   1 1 N {
      [ exch dS mul dup /S ED k mul Radian mul tau0 add /tau ED  x0 y0
        k 0 eq 
           {S tau0 Polar}
           {tau  sin tau0 sin sub k div 
            tau0 cos tau  cos sub k div 
         } ifelse XYadd tau k S S0 add
       ]  
    } for
    case360 {%
       pop %(Case360: replace) == == 
       [x0 y0 tau0 360 k 0. gt {add}{sub} ifelse k S0 S360 add]
           %(by) == dup ==
    } if  
end
} bind

/IntegrateA {%  [f_i] dx --> [y_i]
             % [y_i= int( f(x) dx)],   y(0)=0
%/IntA 2 Args
  [ 0. 4 2 roll exch                   % [0. dx [f]
  dup 0 get                            % [0. dx  [f] f0 
  1 1 3 index length 1 sub {%          % [0. dx  [f] f0 i
     2 index exch get dup              % [... dx [f] f_i-1  f_i f_i
     3 1 roll add 2. div 3 index mul   % [... dx [f] f_i  dg
     4 index add 4 1 roll              % [... dx [f] f_i  
  } for
  pop pop pop ]                        % [dy]
%/IntA_result 1 Args
} bind

/IntegrateF {%  proc(x) x1 x2 N --> [y] dx
%/IntF 4 Args
  [ 5 1 roll exch 2 index sub        % [proc x1 N x2-x1
  1 index div exch 0 1 3 -1 roll     % [proc x1 dx 0 1 N
  {                                  % [proc x1 dx i
     1 index mul 2 index add         % [proc x1 dx xi
     3 index exec 4 1 roll           % [... proc x1 dx
  }
 for 
3 1 roll pop pop             % [... dx
  counttomark 1 add 1 roll ] exch    % [x_i] dx
  dup 3 1 roll IntegrateA exch       % [y_i] dx
} bind

%         Parabolic integration:
% 
/IntegrateP {%  proc(x) a  b N/dx --> Intergal
%/IntP 4 Args
  dup type /realtype eq {1 index 3 index sub exch div ceiling cvi} if
  0. 5 1 roll exch 2 index sub     % 0 proc a N b-a
  1 index div                      % 0 proc a N dx
  2 index 4 index exec 4 1 roll    % 0 proc y(a) a N dx
  dup 2. div 3 -1 roll             % 0 proc y(a) a dx dx/2 N
  {                                % S proc y1 x1 dx dx/2
     3 copy 6 -1 roll add          % S proc y1 dx dx/2 x1 dx x0
     6 index exec 4 mul            % S proc y1 dx dx/2 x1 dx 4*y0
     6 -1 roll add 3 1 roll add    % S proc dx dx/2 4*y0+y1 x2
     dup 5 index exec exch         % S proc dx dx/2 4*y0+y1 y2 x2
     5 2 roll 4 index add          % S proc y2 x2 dx dx/2 4*y0+y1+y2
     1 index mul 3. div
      7 -1 roll add 6 1 roll       % S proc y2 x2 dx dx/2
  } repeat  pop pop pop pop pop 
} bind

/Ctks {% tau0 k s  --> dx dy tau1
 2 copy mul Radian mul dup dup 5 1 roll   % tau ks k s ks ks
 0 eq {%
   pop exch pop 0                         % tau ks s 0 
 } {
   2 div                                  % tau ks k s ks/2
   exch pop dup                           % tau ks k ks/2 ks/2
   cos exch sin dup                       % tau ks k cos(ks/2) sin(ks/2) sin(ks/2)
   4 -1 roll div 2 mul dup 3 1 roll       % tau ks cos(ks/2) card sin(ks/2) card
   mul 3 1 roll mul exch                  % tau ks=dtau dx dy
 } ifelse                                 % tau dtau dx dy
 3 index 0 ne {
      3 index cos 4 index sin XYmul       % tau dtau dx' dy'
 } if
 4 2 roll add
} bind

/KLKL {% [ [k1 l1] [k2 l2] ... ]          --> x y tau
       % [ [k1 l1] [k2 l2] ... ] x0 y0 t0 --> x y tau 
   dup type (arraytype) eq {0. 0. 0.} if
   4 -1 roll                   % x0 y0 t0 [...]
   { aload pop Ctks            % x y dx dy t'
     5 1 roll XYadd 3 -1 roll  % x' y' t'
   } forall 
} bind 

%https://en.wikibooks.org/wiki/PostScript_FA
% Ghostscript has a bubble sort procedure in gs_init.ps.
% <array> <lt-proc> .sort <array>


% Primitive sorting procedure
/Sort {% [x_i] {sortkeyproc}
       %       proc may be:
       %       {}    to sort in increasing order;
       %       {neg} to sort in decreasing order; 
       %       {[1 0 4] {get} forall} to access the element of nested array
       %       other
9 dict begin
%  /ED {exch Pdef} def
  /_sortkey ED
  [ exch aload length dup /L ED dup 1 sub {% [x0 ... x5 6
     dup index _sortkey /xmin ED /lmin 0 def
     dup 1 sub -1  1 {dup /l ED
        index _sortkey % /tested 1 Args 
        dup xmin lt {%
           /xmin ED /lmin l def
        } {pop} ifelse
     } for 
     dup /t ED lmin roll t 1 sub
  } repeat pop
  ] %/EndSort 1 Args
  %  Check
  dup 0 get _sortkey 1 index {_sortkey % prev next
     dup 3 1 roll gt {Pstack SortError} if} forall pop
end
} bind

>> def

/GenSecDict GenSec def
userdict /GenSecLoaded true put

/BPdict <<

/INFflt 1024 /Lamflt 0 /Expflt 1 
/Yflt0 0 /Xflt0 0 /Xflt1 0 /Xflt2 0
/Xmob 0 /Ymob 0 /Xinv 0 /Yinv 0

/SetMobius {% Rmob Lam0
            % Rmob=1, Lam0= +-180 means z0=infty (y0=0, x1 =-2, x2=0)
BPdict begin
  2 copy /Lamflt ED /Expflt ED
  Polar /Yflt0 ED dup /Xflt0 ED dup 1. sub  /Xflt1 ED 1. add /Xflt2 ED
  0 0 FLT /Ymob ED /Xmob ED
  Xflt1 Yflt0 
  2 copy abs exch abs add INFflt div 1. lt
    {pop pop INFflt dup} {Xflt2 neg Yflt0 neg 4 2 roll XYdiv} ifelse
   /Yinv exch def /Xinv exch def
end
} bind

/Cosh {Exp 1. 1 index div add 2. div} bind 
/Sinh {Exp 1. 1 index div sub 2. div} bind 
/Tanh {Exp 1. 1 index div 2 copy sub 3 1 roll add div} bind

/Asinh {dup abs dup dup mul 1 add sqrt add ln exch 0 lt {neg} if}  bind
/Atanh {% atanh(x)=.5*ln[(1+x)/(1-x)] 
   1. exch 2 copy add 3 1 roll sub div ln 2. div
} bind

/Focus 1 
  
/RF2XY {%   rho phi --> x y
  exch 2 copy Cosh exch cos add dup  % phi rho N N
  3 -1 roll Sinh exch div            % phi N x
  Focus mul
  3 -1 roll sin 3 -1 roll div        % x y
  Focus mul
} bind  

/RF2XYT {%   rho phi --> x y tau (tau_to_phi=const; no 90 add
  RF2XY 2 copy 2 copy                      % x y x y x y
  exch         Focus add Atan180 3 1 roll  % x y arg(F+Z) x y
  neg exch neg Focus add Atan180 add Upd180
} bind

/RF2Tcum {%  rho phi --> Theta
   2 copy Upd180 dup 4 -1 roll sub -360. div       % rho rho phi180 n
   round 360 mul 3 -1 roll Signum mul neg 3 1 roll % add rho phi180
   2 div dup cos 3 1 roll sin exch                 % add cos(phi/2) sin(phi/2) rho
   Exp 1. 2 copy add 4 1 roll  sub mul             % add cos(phi/2) exp+1 sin(phi/2)*(exp-1)
   3 1 roll mul Atan90 -2 mul add
} bind

/XY2RF {%   x y --> rho phi                    % 
  Focus div exch  Focus div exch
  2 copy  dup mul exch                         % x y y^2 x
  2 copy   1 add dup mul add                   % x y y^2 x   h1^2
  3 1 roll 1 sub dup mul add div               % x y h1^2/h2^2
  ln 2 div 3 1 roll                            % rho x y
  dup 2 mul 3 1 roll                           % rho 2y x y
  dup mul exch dup mul add 1 exch sub          % rho 2y 1-x^2-y^2
  atan Upd180
} bind 

/ups {% rho phi
    dup sin exch cos 3 -1 roll abs Exp add Atan90
} bind

/upsbar {% rho phi
    180 add ups neg
} bind

/Ups {% rho phi
%   2 copy ups 2 mul sub exch Signum mul
    dup sin 1 index cos 3 index abs Exp add Atan90 2 mul sub exch Signum mul
} bind

/Ups0 {% rho phi
    2 div dup sin exch cos              % rho sin(phi/2) cos(phi/2)
    3 -1 roll 2 div Exp 1. 1 index div  % sin(phi/2) cos(phi/2) exp 1/exp
    2 copy sub 5 -1 roll mul 4 1 roll
    add mul Atan90 2 mul
} bind

/UpsInv {% rho phi
    1 index 0 eq {(UpsInv[0,phi] !!!) ==} if
    dup sin 1 index cos 3 index abs Exp exch sub Atan90 2 mul add exch Signum mul
} bind
>> def
% --------------------------------------------------------- GenSec.ps end

%(FresnelDict.ps) runlibfile 
/FresnelDict
%      SUBROUTINE SF45R(arg,C,S)
%      DIMENSION A(52),RK(13),RL(13)
%      INTEGER K,L,I
%      REAL X,C,S,A,RK,RL,Z,H,Y,F,D,E,B,R,T,SYS035
<< /A [ 
           .1E-10      -.366E-9      .10898E-7   -.267681E-6  .527608E-5 
          -.8105684E-4  .9339901E-3 -.7651297E-2  .0411409E0 -.1271339E0 
           .1743607E0  -.0808111E0   .5479103E0   .4E-11     -.128E-9 
           .4206E-8    -.11507E-6    .2562196E-5 -.4532192E-4 .6174202E-3 
          -.6220184E-2  .0438681E0  -.2007174E0   .5386666E0  -.7996168E0 
          1.053859E0    .1E-11      -.4E-11       .14E-10     -.54E-10 
           .239E-9     -.1176E-8     .6545E-8    -.42829E-7    .347441E-6  
          -.3810219E-5  .6627508E-4 -.2617529E-2  .9945488E0   .2E-11
          -.6E-11       .18E-10     -.72E-10      .298E-9     -.1346E-8 
           .6798E-8    -.39518E-7    .275996E-6  -.2475448E-5  .3202967E-4
          -.7552029E-3  .0608819E0
     ] 

%   /SYS035  0.3989422
   /RK 13 array 
   /RL 13 array 
   /K null /L null /I null
   /X null /C null /S null /Z null /H null /Y null /F null 
   /D null /E null /B null /R null /T null

/Fresnel % s_arg  --> C S  (x,y)
{        %
         %   k=s/2, tau=s^2/4, ...  x,y(inf)=sqrt(Pi/2)
         % 
  FresnelDict begin 
      dup 
%      abs /Z exch def
       abs 2. div dup mul /Z exch def
      Z 8. lt {/H Z  8. div def /K 0 def}
              {/H 8. Z  div def /K 26 def} ifelse
      /L K 13 add def
      /Y 4. H H mul mul 2. sub def

      RK 0 A K get put
      RK 1 Y RK 0 get mul A 1 K add get add put
      RL 0 A L get put
      RL 1 Y RL 0 get mul A 1 L add get add put
%      DO 4 I=3,13
%      RK(I)=Y*RK(I-1)-RK(I-2)+A(I+K)
%      RL(I)=Y*RL(I-1)-RL(I-2)+A(I+L)
%    4 CONTINUE

      2 1 12
      {/I exch def
       RK I Y RK I 1 sub get mul RK I 2 sub get sub A I K add get add put
       RL I Y RL I 1 sub get mul RL I 2 sub get sub A I L add get add put
      } for

      /F 0.3989422 def
      /D F RK 12 get mul def
      /E F RL 12 get mul H mul def
      /B Z sqrt def
%      IF(Z-8.) 5,6,6
%    5 C=D*B
%      S=E*B
%      GO TO 7
%    6 R=SIN(Z)
%      T=COS(Z)
%      C=.5+(D*R-E*T)/B
%      S=.5-(E*R+D*T)/B
      Z 8. lt 
      {D B mul E B mul}
      {Z 57.29577950 mul dup
        sin /R exch def cos /T exch def
       .5 D R mul E T mul sub B div add  
       .5 E R mul D T mul add B div sub} ifelse 

%     3 -1 roll 0. lt {neg exch neg exch} if
      2.506628274 4 -1 roll   % C S sqrt(2Pi) arg
      0 lt {neg} if dup
      4 -1 roll mul 3 1 roll mul    
 
%    7 RETURN
%      END
  end
} bind

/KCornu {% S --> x y tau k
   dup Fresnel 3 -1 roll                % [ x y s 
   2 div dup dup mul Radian mul exch    % [ x y Tau1 k=s/2
} bind

/NCornu {% S1 S2 N --> [ [K0] ... [KN]]   K_i=[x y t k 0 s]
9 dict begin
  3 copy /N exch def exch sub exch div /dS exch def    % s1 s2
  exch dup /S1 exch def
  Fresnel 3 -1 roll Fresnel                            % x1 y1 x2 y2
  LocalXY   /Y0 ED /X0 ED /Mu ED /HalfChord ED /Sin Mu sin def /Cos Mu cos def
[/HalfChord HalfChord] ==
%   /Matrix [Mu cos HalfChord div
%            Mu sin HalfChord div dup neg exch 2 index          % cos -sin sin cos
%            4 copy X0 mul exch Y0 mul add neg 3 1 roll         % ...              tx cos -sin
%                   X0 mul exch Y0 mul add neg] def
  [ 0 1 N {%
     dS mul S1 add [ exch dup 
     Fresnel X0 Y0 XYsub                                % [ s x y 
     Cos HalfChord div Sin neg HalfChord div XYmul 
     3 -1 roll dup 2 div dup dup mul Radian mul Mu sub 3 1 roll % [ x y Tau s s/2
     HalfChord mul exch HalfChord div 0 exch
     ]
   } for ]
end
} bind
>> def

%(BiarcDict.ps)  runlibfile
%!
userdict begin
/ED {exch def} bind def

/BiarcData <<
   /Alpha 0 /Beta 0 /Gamma 0 /Omega 0 /Bpar 0 
   /Acum  0 /Bcum 0 /Sigma 0 /Rho1 0 /Rho2 0
   /XJ 0    /YJ 0   /TauJ  0 /Len1 0  /Len2 0
   /Ninf 0   % 0, 1, 2
   /kn1  0 /kn2 0 /SinOmg 0  /SinA 0 /SinB 0
   /K1 [] /K2 [] /Kinf []
   /HalfChord 1 /Mu 0 /BiMatrix matrix identmatrix /X0 0 /Y0 0
%  /Modified null
>> def

/BiarcDict <<

/Ldiscont 2.  %  --- length of infinite lines, equal to Chord length by default

/BiarcInitXY {% [X1 Y1 X2 Y2]
 BiarcData begin
   aload length 4 eq {%
     LocalXY   /Y0 ED /X0 ED 
     /Mu ED /HalfChord ED                                      % Check Mu undefined
     /BiMatrix [Mu cos HalfChord div
            Mu sin HalfChord div dup neg exch 2 index          % cos -sin sin cos
            4 copy X0 mul exch Y0 mul add neg 3 1 roll         % ...              tx cos -sin
                   X0 mul exch Y0 mul add neg] def
     %/Matrix 6 array identmatrix def
   } {
     /HalfChord 1 def /Mu 0 def /BiMatrix matrix identmatrix def /X0 0 def /Y0 0 def
   } ifelse
 end
} 

 %%%%%%%%%%%%  Returns incorrect XJ, YJ, ... in the case of BiarcInitXY

/MakeBiarc {% Alpha Beta par type  -->  (fill dict) 
            %  -1: discontinuous biarc
            %   0: p-parameter
            % 1,2: first or second curvature
            %   3: tau_J  
            %  90: Ang, p=tan(Ang)  ???
  BiarcData begin % currentdict dup /kn1 undef /kn2 undef
%  /MakeBia 4 Args [/c HalfChord /Mu Mu /MX BiMatrix aload pop] ==
     4 2 roll Mu sub exch Mu sub exch     % par type A B
     2 copy add 2. div sin /SinOmg ED     % par type A B          % store original sin(omega)   
              2 copy exch                 % par type A B  B A
     abs 180 eq {%
         Upd180 exch pop                  % par type A B'
     } {%                                 % par type A B B
         abs 180 eq {%                    
            exch Upd180 exch              % par type A' B 
         } {%  general case               % par type A  B 
            Upd180 exch Upd180 exch       % par type A' B'
         } ifelse  
     } ifelse                             % par type A' B'   
     2 copy add 2. div dup /Omega ED sin  % par type A' B' sin(o)
%    dup SinOmg mul 0 lt /Modified exch def    % par type A' B' sin(o) 
     /SinOmg ED
     2 copy sub 2 div /Gamma ED
     dup sin /SinB ED /Beta ED  dup sin /SinA ED /Alpha ED
     _MakeBiarc
%   currentdict Pdict 
  end 
}

/_K5XY {% xn yn taun kn Ln
   1 index 0 eq {HalfChord mul} if 5 1 roll HalfChord div 5 1 roll Mu add 5 1 roll BiMatrix itransform 5 2 roll
}

/_CrvCheck {%  replace curvature by 0 if too small
   dup abs 0.0001 lt {pop 0.} if
}

/_MakeBiarc {%     par type  -->  (fill dict) 
             % 
 /Ninf 0 def
 dup -1 eq {%
    pop pop
    Alpha cos Beta cos le {0 1}{0 2} ifelse dup /Ninf exch def
 } if 

 dup 8 eq {pop 7} if	
 dup 7 eq {DeprecatedBiarcPar} if	
 dup 90 eq {pop Tan 0} if	

 dup 3 eq {%  tauJ is given;  p = -sin(t/2+b/2)/sin(t/2+a/2)
    pop dup
    Beta  add 2 div sin neg exch
    Alpha add 2 div sin div         0 
 } if

 dup 0 eq {%
    1 index dup /Bpar ED                            % par typ=0 par
    dup SinOmg mul SinB add      _CrvCheck /kn2 ED  % par typ=0 par
    SinOmg neg exch div SinA sub _CrvCheck /kn1 ED
 } if 

 dup 1 eq {%
    1 index HalfChord mul dup /kn1 ED                % par typ=1 kn1
    SinA add neg SinOmg exch div dup /Bpar ED        % par typ   Bpar
    SinOmg mul SinB add _CrvCheck /kn2 ED
 } if 

 dup 2 eq {%
    1 index HalfChord mul dup /kn2 ED                % par typ=2 kn2
    SinB sub SinOmg div dup /Bpar ED                 % par typ   Bpar
    SinOmg neg exch div SinA sub _CrvCheck /kn1 ED
 } if 
 pop pop

 Alpha cos Beta cos 2 copy  
    le kn1 0 eq and {/Ninf 1 def} if
    ge kn2 0 eq and {/Ninf 2 def} if

	% Check data
 0                                                   % ierror  
 Omega abs 180 ge                        {1 add} if
	Omega Bpar mul  kn2 kn1 sub mul 0 lt   {10 add} if  % bool1 bool2
	Beta abs 180 gt Alpha abs 180 gt  or  {100 add} if
 SinOmg 0 eq                          {1000 add} if
 Alpha abs 180 eq 
 Beta  abs 180 eq or Ninf 0 gt and   {10000 add} if
 dup 0 gt {== currentdict Pdict BadAngles}{pop} ifelse
	
 kn1 kn2 eq {
   /TauJ Omega def
 } {
   /TauJ Bpar Alpha 2 div Polar 1. Beta 2 div Polar XYadd neg exch  Atan90 2 mul def
      Bpar 2 mul Gamma Polar Bpar dup mul 1 add            % 2Bcos 2Bsin B^2+1
      3 -1 roll add dup 0.00001 lt                         % 2Bsin denom bool
        {pop pop 99 99}
        {Bpar 1 sub Bpar 1 add mul 1 index div 3 1 roll div % XJ YJ
        } ifelse /YJ ED /XJ ED
 } ifelse

 kn1 0 ne {
    kn1 Alpha cos Omega cos Bpar div add Atan180 2 mul dup Radian div kn1 div    % Rho1 Len1
 }{
    0 XJ 1 add dup mul YJ dup mul add sqrt
 } ifelse /Len1 ED /Rho1 ED

 kn2 0 ne {
    kn2 Beta  cos Omega cos Bpar mul add Atan180 2 mul dup Radian div kn2 div    % Rho2 Len2
 }{
    0 XJ 1 sub dup mul YJ dup mul add sqrt
 } ifelse /Len2 ED /Rho2 ED

 kn1 kn2 mul 0 lt {%
	   /Acum TauJ Rho1 sub def /Bcum TauJ Rho2 add def
	} {%
	   kn1 abs kn2 abs lt {
	      /Acum Alpha def /TauJ Acum Rho1 add def /Bcum TauJ Rho2 add def
	   }{%
		     /Bcum Beta  def /TauJ Bcum Rho2 sub def /Acum TauJ Rho1 sub def
    } ifelse
		  Ninf 0 gt {/Acum Alpha def /Bcum Beta def} if
 } ifelse	 
 /Acum Acum Alpha sub round Alpha add def   % rounding to +-360 or 0
 /Bcum Bcum Beta  sub round Beta  add def
	 
	/Sigma Ninf 0 gt {Omega 2 mul dup 0 gt {360 sub}{360 add} ifelse} {Acum Bcum add} ifelse def 
	kn2 kn1 sub Sigma mul 0 lt {currentdict Pdict VogtFailure} if

 /K1 [-1 0 Alpha kn1 dup 0 eq {%
     Ninf 0 gt {Ldiscont} {Len1} ifelse
 }{Rho1 abs} ifelse 
  _K5XY] def

 /K2 [ XJ YJ TauJ kn2 Rho2 abs 1 index 0 eq {%
     pop                              %  /K2 [ XB YB TauB 0
     Ninf 0 gt {pop pop pop pop 1 0 Ldiscont Beta Polar XYsub Beta 0 Ldiscont} {Len2}  ifelse
 } if
  _K5XY] def  

/Kinf [
%    Ninf 2 eq {XJ YJ Ldiscont Beta  Polar XYadd Beta  0. Ldiscont _K5XY} if
     Ninf 2 eq {XJ YJ                            Beta  0. Ldiscont _K5XY} if
     Ninf 1 eq {XJ YJ Ldiscont Alpha Polar XYsub Alpha 0. Ldiscont _K5XY} if
 ] def
 /Len1 Len1 HalfChord mul def /Len2 Len2 HalfChord mul def
  Len1 0 lt Len2 0 lt or {[Len1 Len2] == BadLengthes} if
% [K1 Kinf K2] ==
} 

/BiarcDraw^ {%  dict
  begin
  Ninf 0 gt {% 
     Kinf length 0 eq {%
		      K1 Kdraw K2 Kdraw
		   }{
        kn1 0 eq {K1 Kdraw Kinf Kdraw^}{K1 Kdraw^ Kinf Kdraw} ifelse K2 Kdraw
     } ifelse		   
  }{%
		   K1 Kdraw^ K2 Kdraw
  } ifelse 
  end
} 

/BiarcDraw {%  dict
   begin
    Ninf 0 gt {% 
        Kinf length 0 eq {%
		   K1 Kdraw K2 Kdraw
		}{
           kn1 0 eq {K1 Kdraw Kinf Kdraw}{K1 Kdraw Kinf Kdraw} ifelse K2 Kdraw
        } ifelse		   
    }{%
		K1 Kdraw K2 Kdraw
    } ifelse 
   end
} 

/MakeBilens {% Alpha Beta p1 p2  -->  dict 
  << 5 1 roll
     4 copy pop 0 MakeBiarc
     BiarcData begin
       /Alpha Alpha /Beta Beta /Sigma Sigma /Gamma Gamma /Omega Omega
       /B1.Bpar Bpar /B1.XJ XJ    /B1.YJ YJ   /B1.TauJ TauJ
        /k1  kn1 /g2 kn2 /K1 K1 /G2 K2
        /QB kn1 SinA add
     end
     counttomark -4 roll exch pop 0 MakeBiarc
     BiarcData begin                      % /QB  k1+SinA
       kn2 SinB sub mul Sigma 2 div sin dup mul add
       /B2.Bpar Bpar /B2.XJ XJ    /B2.YJ YJ   /B2.TauJ TauJ
       /g1  kn1 /k2 kn2  /G1 K1 /K2 K2
     end 
  >>
}

/TPdata <<
  /Len 0 /KP1 [] /KP2 [] /KP3 [] /KP4 [] /A 0 /B 0 /Tau 0 /Nu 0
>> 

/TriarcP {% p         (Alpha Beta p1 p2 in working dict)
TPdata begin
  Alpha Beta 3 -1 roll 0 MakeBiarc 
  BiarcData begin 
    /TJ TauJ  /XJ XJ  /YJ YJ  /P0 Bpar
    /Theta 1 Bpar sub 1 Bpar add mul Gamma sin mul 
           Bpar dup mul 1 add Gamma cos mul 2 Bpar mul add  Atan180 
  end 
  def def def def def
  /A P0 dup mul p1 p2 mul add 2 P0 mul p1 mul sub def
  /B P0 dup mul p1 p2 mul add 2 P0 mul p2 mul sub def
  /Nu B
    P0 p2 p1 sub mul p2 P0 sub mul P0 p1 sub mul sqrt 2 mul add
    Omega 2 div Tan mul A Atan90 2 mul def
  /Tau Theta Nu add def

  [-1 0 XJ YJ] BiarcInitXY 
  Alpha Tau k1 1 MakeBiarc
%  BiarcData BiarcDraw stroke
  BiarcData begin
    /KP1 [ K1 aload pop] /KP2 [K2 aload pop] /Len1 Len1 /Len2 Len2
  end def def def def

  [XJ YJ 1 0] BiarcInitXY 
  Tau Beta k2 2 MakeBiarc
%  BiarcData BiarcDraw stroke
  BiarcData begin
    /KP3 [ K1 aload pop] /KP4 [K2 aload pop] /Len3 Len1 /Len4 Len2 
  end def def def def
end
}
>> def
end   % pop userdict


GenSec begin BPdict begin

FigDict begin %--------------- Start Loading FigDict ----------------------       

/GrayLevel 0.95 def


/ArrowDict << /Lback 2  /Lforw 6  /Lwid 3 
   /ArrowType 2    % 0: no arrow; 1: normal arrow: 2: curvilinear arrow (Moebius)
   /ArrowCrv  0    % basic curvature (for Moebius)   
>> def

/ArrowSet {%  [Lback Lforw Lwid] or [] to set defaults
  ArrowDict begin aload length 0 eq {2 6 3} if  /Lwid ED /Lforw ED /Lback ED   end
} bind def

/ArrowScale { % scale_factor
  [] ArrowSet
  ArrowDict begin  dup Lwid mul /Lwid ED dup Lforw mul /Lforw ED Lback mul /Lback ED   end
} bind def

/PicScale {% scalefactor
  PicDict begin
    1. PicScal div dup scale 
    dup 0 le {pop}{dup dup scale dup /PicScal ED 1. exch div setlinewidth} ifelse
  end
} bind def

/PicLW {% LineWidth
  PicDict begin PicScal div setlinewidth end
} def

/Picmm {% N 
  595 mul 210 div PicDict begin PicScal div end
} def

/PicBegin {% [x1 y1 x2 y2] scale 
   dup 0 gt {PicScale} {pop} ifelse
   PicDict begin
     aload length 0 gt {
      [/PicY2 /PicX2 /PicY1 /PicX1] {exch def} forall
      /PicW PicX2 PicX1 sub def  
      /PicH PicY2 PicY1 sub def
     } if
     PicX1 neg PicY1 neg translate
   end
} bind def

/PicBox {% --> x1 y1 x2 y2
   PicDict begin PicX1 PicY1 PicX2 PicY2 end
} def

%/PicFrame {% [x1 y1 x2 y2] (optional false_translate) --> output clipping path
%   dup type /booleantype ne {true} if exch
%   PicDict begin 
%     aload length 0 ne
%     { [/PicY2 /PicX2 /PicY1 /PicX1] {ED} forall} if
%     /PicW PicX2 PicX1 sub def  
%     /PicH PicY2 PicY1 sub def
%     {PicX1 neg PicY1 neg translate} if
%     PicMX currentmatrix pop
%     PicPath
%   end
%} def

/PicFont {%  /FontName scale
   exch 
   << /T /Times-Roman /TI /Times-Italic                % My abbreviations
      /H /Helvetica   /HB /Helvetica-Bold /S /Symbol
      /C /Cyr-abc  % (for Cyrillic-Italic_abv...) --- to mark sub_pictures only
   >> 1 index 2 copy known {get exch pop}{pop pop} ifelse   
   findfont exch PicDict /PicScal get div scalefont setfont
   PicDict /PicMinus currentfont /FontName get /Symbol eq {(\055)}{(\261)} ifelse put
} def

/PicAxes {%      (X_text) (Y_text) [x1 y1 x2 y2 --- optional array]
                 % (text) = (-)  --> do not draw axis
                 % (text) = (.*) --> show text from the other side of the axis
  dup type /arraytype eq
  {aload pop}{PicBox} ifelse            % (Xtxt) (Ytxt) x1 y1 x2 y2
  3 -1 roll 5 -1 roll                   % (Xtxt) x1 x2 y2 y1 (Ytxt)
  ArrowDict begin
    dup (-) eq
    {pop pop pop}
    {%                                  % (Xtxt) x1 x2 y2 y1 (Ytxt) 
     3 1 roll 0. exch moveto 0. exch l^ 
     dup length 0 eq
     {pop}
     {Lwid currentlinewidth mul 1.2 mul exch       % |dx| (Ytext)
      (.) search {pop pop exch neg 0 rmoveto 1.}{exch 0 rmoveto 0.} ifelse
      1. set_text show
     }ifelse 
    }ifelse                             % (Xtxt) x1 x2
    2 index (-) eq
    {pop pop pop}
    {exch 0. moveto 0. l^ 
     dup length 0 eq
     {pop}
     {0 Lwid currentlinewidth mul 1.2 mul 3 -1 roll       % 0 |dY| (Xtext)
      (.) search {pop pop 3 1 roll rmoveto 0.}{3 1 roll neg rmoveto 1.} ifelse
      1. exch set_text show
     }ifelse
    }ifelse  stroke
  end
} def

/PicPath {%  output clipping path
   PicDict begin 
     newpath
     PicX1 PicY1 moveto PicW 0 rlineto 0 PicH rlineto PicW neg 0 rlineto
     PicX1 PicY1 lineto       
   end
} def

%/forallXY {%  [array: x0 y0 x1 y1 ...] {proc} 
%  false 3 1 roll [[3 -1 roll false] cvx {true} /ifelse] cvx forall pop
%} def 

/ArrowHead {% (curr.pt.context) Lback Lforw Lwid dir
%                                2  6  3  
%     draw arrow head from current point in given direction 

%  gsave Red 3 PicLW currentpoint newpath moveto 3 copy exch pop Polar rlineto 5 Rpoint stroke grestore

  gsave currentpoint newpath 0 setlinecap 0 setlinejoin
    translate 
       rotate
       0 0 moveto                                      % Lback Lforw Lwid
       3 -1 roll neg exch 2 copy lineto                % Lforw -Lback Lwid
       3 -1 roll 0 lineto                              % -Lback Lwid
       neg lineto closepath fill
  grestore
} bind def

/rl^ {% dx dy [optional_arrow_descr] :  rlineto-arrow
%                                          2  6  3  
  dup type /arraytype ne {ArrowDict begin Lback Lforw Lwid end}
                         {aload pop} ifelse          % dx dy Lback Lforw Lwid 
  3 {currentlinewidth mul 5 1 roll} repeat           % Lback Lforw Lwid dx dy
  gsave 2 copy rmoveto currentpoint 7 2 roll grestore% x y Lback Lforw Lwid dx dy
  exch 2 copy dup mul exch dup mul add sqrt          % x y Lback Lforw Lwid dy dx dl
  3 1 roll atan exch                                 % x y Lback Lforw Lwid fi dl 
  3 index sub dup 0 lt {pop 0} if                    % x y Lback Lforw Lwid fi dl'
  1 index 2 copy cos mul 3 1 roll sin mul rlineto    % x y Lback Lforw Lwid fi       
      ArrowHead 
  moveto   % restore user_expected current point
} bind def

/l^ %%%% def   lineto-arrow
{%
   	currentpoint 3 -1 roll sub neg 
        3 1 roll sub exch rl^
} bind def

/crv^ {%  (curr.pt.context) x1 y1 x2 y2 x3 y3  curveto_arrow
3 {currentpoint 8 -2 roll 3 -1 roll sub 3 1 roll sub neg exch} repeat rcrv^
} bind def

/rcrv^ {% rcurveto_arrow:  (curr.pt.context) x1 y1 x2 y2 x3 y3
 2 copy currentpoint 10 4 roll 4 copy   % p3 p0 p1 p2 p3 p2 p3 
 3 -1 roll sub 3 1 roll sub neg exch    % p3 p0 p1 p2 p3 p3-p2
 dup mul exch dup mul add sqrt 3. mul   % p3 p0 p1 p2 p3 3|p3-p2|
 dup 0. eq {(Singular EndPoint) ==} if  % p3 p0 p1 p2 p3 3|p3-p2|
 ArrowDict /Lforw get                                                 %???
 currentlinewidth mul exch div          % p3 p0 p1 p2 p3  dt         %???   
 dup 1. gt                                                           %???
 %{9 {pop} repeat rl^ }              %   just rl^ to end pt
 {pop rcurveto pop pop pop pop}      %   just rcurveto to end pt
 {dup neg 1. add dup 2 copy mul dup %   ... dt t1=(1-dt) t1 t1^2 t1^2
  dup 3 index mul dup                       6 {8 -1 roll mul 7 1 roll} repeat
  dup 2 mul dup                 2 {7 index mul 6 -1 roll add 5 1 roll} repeat
  dup 2 {4 index 7 index 2 index mul sub mul 3 mul 3 -1 roll add exch} repeat
  rcurveto  3 -1 roll add 3 1 roll add exch l^
 } ifelse
} bind def

/Rpoint {%  Radius  (R<0 --- fill with white)  (curr.point) 
    gsave currentpoint newpath [] 0 setdash translate dup 0 ge 
      {PicLW 1 setlinecap 0 0 moveto 0 0 rlineto}
      {-2 div PicDict /PicScal get div 0 0 3 -1 roll 0 360 arc closepath clip 
             gsave 1 setgray fill grestore
      } ifelse stroke
    grestore
} bind def

/Rcross {% R >< 0
%  Picmm
  gsave currentpoint translate newpath [] 0 setdash  
     dup 0 lt {45 rotate abs} if
     dup PicDict /PicScal get 
     div dup scale  % now as if "|size| dup scale"
     currentlinewidth exch div setlinewidth
     -1 0 moveto 1 0 lineto 0 -1 moveto 0 1 lineto stroke                   
  grestore     
} bind def


/_Arc0 {%  (curr.pt) if_arrow tau length  --> new_Tau (= tau)
   %/_Arc0: 3 Args
    2 copy exch Polar 3 -1 roll                   % if_arr tau dx dy len   
    0. ge
    {4 -1 roll  {rl^} {rlineto} ifelse}           % tau
    {% line through infinity
     currentpoint 3 -1 roll add 3 1 roll add exch % if_arr tau xdest ydest
     KdrawLength 3 index Polar 2 copy rlineto     % if_arr tau xdest ydest DX DY
     -2 mul exch -2 mul exch rmoveto              % if_arr tau xdest ydest  
     4 -1 roll  {l^} {lineto} ifelse
    } ifelse  
} bind def

/_Arc90 {%  (curr.pt) tau k rot_or_length(if k=0) arrow  --> new_Tau
   %/Arc90: 4 Args
   % rotation =< 90, sign correct
    4 1 roll
    1 index 0. eq                             % arr tau k rot/s  k=0 
    {exch pop _Arc0} 
    {dup 3 index add 4 1 roll                 % arr tau k rot  
     2 div dup 3 index add 3 1 roll           % arr tau' tau mu k r/2
     dup 3 1 roll sin exch div abs 2 mul      % arr tau' tau mu r/2 2c
     dup 4 -1 roll Polar 5 2 roll              % arr tau' x3 y3 tau r/2 2c 
     exch cos 1 add 3 mul div 2 mul dup        % arr tau' x3 y3 tau p p (p=4c/3/(1+cos))
     3 -1 roll Polar 5 2 roll                  % arr tau' x1 y1 x3 y3 p 
     5 index 180 sub Polar                     % arr tau' x1 y1 x3 y3 dx2 dy2 
     2 index add 4 1 roll                      % arr tau' x1 y1 y2  x3 y3 dx2   
     2 index add 4 1 roll                      % arr tau' x1 y1 x2 y2 x3 y3
     8 -1 roll {rcrv^} {rcurveto} ifelse
    } ifelse
    %(Arc90 OK) ==
} bind def

/_Arc {%  (curr.pt) bool_arrow tau k len/rot --> new Tau
   %/_Arc 4 Args
   1 index 0. eq 
   {exch pop _Arc0}
   { % update sign of rotation  
     2 copy mul 0. lt {neg} if                         % bool tau k rot
     dup abs 90 div ceiling dup cvi 3 1 roll div exch  % bool tau k rot/N N 
     1 sub
     {                                                 % bool tau  k d_rot  
        3 copy false _Arc90 4 -1 roll pop 3 1 roll     % bool tau' k d_rot
     } repeat 
     4 -1 roll _Arc90
   } ifelse 
   %(Arc OK) == %pstack
} bind def

/_ArcTo {%  (curr.pt) tau xdest ydest --> tau k len/rot
     currentpoint 4 2 roll LocalXY pop pop              % tau c mu
     %  k = sin(mu-tau)/c
     2 index sub Upd180 dup sin dup 0. eq               % tau c tau-mu sin(t-m) k=0
     3 index 0. eq  or                                  % ..... k=0_or_c=0                   
     {pop abs 179 gt {neg} if 0. exch}                  % tau 0. l=+-c
     {3 -1 roll div exch} ifelse 2. mul                 % tau k l/rot
} bind def 
  

/Arc {%  (curr.pt) tau k len/rot --> new_Tau
   false 4 1 roll _Arc
} bind def

/Arc^ {%  (curr.pt) tau k len/rot --> new_Tau
   1 index 0. eq 
   {exch pop true 3 1 roll   _Arc0}
   {%
     2 copy ArrowDict /Lforw get 2 index mul abs       % tau k rot k rot |L*k|
     currentlinewidth mul //Radian mul exch            % tau k rot k dr rot
     1 index sub 0 lt {%                               % tau k rot k dr   
     	 pop pop Arc
     }{%                                               % tau k rot k dr 
        1 index 6 3 roll 4 index sub Arc               % k dr k tau'
        3 1 roll exch                                  % k tau' k dr
        gsave 
%                              gsave currentpoint newpath moveto Green 4 PicLW 3 copy Arc pop stroke grestore
           Arc currentpoint 
        grestore 4 -1 roll     % taunew xnew ynew k
        ArrowDict /ArrowType get 2 eq{%
          ArrowHeadCrv      
        }{%
           pop l^
        } ifelse
     } ifelse
   } ifelse  
} bind def

/_Arc3 {%  (curr.pt) x1 y1 x2 y2 --> tau x2 y2 
%   gsave 4 copy moveto 3 Rpoint moveto 3 Rpoint grestore 

   2 copy currentpoint XYsub exch atan 5 1 roll % mu0 x1 y1 x2 y2
   4 copy XYsub neg exch neg      atan 5 1 roll % mu0 mu2 x1 y1 x2 y2
   6 2 roll currentpoint XYsub exch atan        % x2 y2 mu0 mu2 mu1
   exch sub add 3 1 roll
} bind def

/Arc3 {%  (curr.pt) x1 y1 x2 y2
    _Arc3 _ArcTo Arc
} bind def

/Arc3^ {%  (curr.pt) x1 y1 x2 y2
   _Arc3 _ArcTo Arc^
} bind def

%------------------------------------------------------- KKlib
%   [ x0 y0 tau k rot_or_len par ...]
%-------------------------------------------------------------

/Kload {%  [x y t k ...]  N_to_keep  --> x y t ... (Poss. nulls added)
         exch aload length dup 2 add -1 roll
         sub dup 0 ge {{pop}} {neg {null}} ifelse repeat
} bind def

/_Kdraw {% [x y t k l/rho ...]  ---> (curr_pt) t k l/rh
         % Prepare curr. point and args for Arc or Arc^
  5 Kload 5 -2 roll moveto                      % t k len/rho
  %  allow l/rh=0/null
  dup dup null eq exch 0. eq or 
  { % to be corrected
    pop dup 0. eq {KdrawLength} {360} ifelse    % t k l/rh  
  } if
} bind def

/Kdraw {% [x y t k l/rho ...]
   _Kdraw Arc pop
} bind def

/Kdraw^ {% [x y t k l/rho ...]
   _Kdraw Arc^ pop
} bind def

/Kdraw^^ {% [x y t k l/rho ...]
   gsave newpath dup _Kdraw 2. div Arc^ pop grestore
   Kdraw 
} bind def

%currentdict length ==
end % --------------- End Loading FigDict ----------------------       

/G2HermiteDict <<

/G2Make_uvgk {%  t --> u v g(=ds/dt) k
%/t 1 Args
    dup dup mul 2 copy 2 copy           % t tt t tt t tt
    CoeffDict begin                     % ...  ...  ...
      CX0 CX1 CX2 9 3 roll              % t tt cx0 cx1 cx2 t tt t tt t tt 
      CY0 CY1 CY2 7 3 roll              % 
      CW0 CW1 CW2 5 3 roll              % cx0 cx1 cx2 t tt cy0,1,2 t tt cw0,1,2 t tt
%      /X2 CX0 /Y2 CY0 /W2 CW0
    end
%   Work dict created in calling program, G2MakeKS or G2MakeCurve4

    2 index mul 5 -1 roll add        % ... c1 c2 t c2*t^2+c0
    3 index 2 index mul add /W ED    % ... c1 c2 t
    exch 2. mul dup /W2 ED           % ... c1 t 2*c2
    mul add /W1  ED                  % ... 

    2 index mul 5 -1 roll add        % ... c1 c2 t c2*t^2+c0
    3 index 2 index mul add /Y ED    % ... c1 c2 t
    exch 2. mul dup /Y2 ED           % ... c1 t 2*c2
    mul add /Y1  ED                  % ... 

    2 index mul 5 -1 roll add        % ... c1 c2 t c2*t^2+c0
    3 index 2 index mul add /X ED    % ... c1 c2 t
    exch 2. mul dup /X2 ED           % ... c1 t 2*c2
    mul add /X1  ED                  % ... 
    % u+iv=(mW+nZ)/(nW+mZ); n^2-m^2=4*RB0*exp(iLB0); 
    % dtmp=WZ'-W'Z;  denom=(nW+mZ); rtmp=(n^2-m^2)/denom^2
    % u'+iv'=rtmp*dtmp;
    % u''+iv''=rtmp * [ WZ''-W''Z-2*dtmp*(nW'+mZ')/denom]

    Xflt2 W mul Yflt0 W mul Xflt1 Yflt0 X Y XYmul XYadd  % denom
    2 copy 2 copy dup mul exch dup mul add /NNW ED
    Xflt1 W mul Yflt0 W mul Xflt2 Yflt0 X Y XYmul XYadd  % denom denom num
    4 copy XYmul /NNY ED /NNX ED
    4 2 roll
    %/Xydiv1 4 Args % --zeros in symmetric case and phi=0 -----
             XYdiv 4 2 roll 2 copy 2 copy XYmul        % U V denom denom^2
    Xflt0 4. mul Yflt0 4. mul 4 2 roll XYdiv 2 copy    % U V denom rtmp rtmp
    X1 W mul Y1 W mul  X W1 mul Y W1 mul XYsub 2 copy  % U V denom rtmp rtmp dtmp dtmp
    6 -2 roll XYmul 2 copy                             % U V denom rtmp dtmp U' V' U' V'
%2 copy exch atan Upd180 /Tau 1 Args pop
    dup mul exch dup mul add dup sqrt exch 10 4 roll   % U V U' V' G GG denom rtmp dtmp 
    -2. mul exch -2. mul exch 6 -2 roll XYdiv          % U V  U' V' G GG rtmp term2
    Xflt2 W1 mul Yflt0 W1 mul Xflt1 Yflt0 X1 Y1 XYmul XYadd  % ... denom'
    XYmul
    X2 W mul Y2 W mul  X W2 mul Y W2 mul XYsub XYadd   % U V  U' V' G GG trmp term
    XYmul                                              % U V  U' V' G GG U''V''
    6 -1 roll mul exch                                % U V V' G GG U'V'' U''
    5 -1 roll mul sub exch div 1 index div            % U V G k
} bind

/SetMobius {% Rmob Lam0
            % Rmob=1, Lam0= +-180 means z0=infty (y0=0, x1 =-2, x2=0)
BPdict begin
  2 copy /Lamflt ED /Expflt ED
  Polar /Yflt0 ED dup /Xflt0 ED dup 1. sub  /Xflt1 ED 1. add /Xflt2 ED
  0 0 FLT /Ymob exch def /Xmob exch def
%
%       1-x0^2-y0^2 + 2*I*y0              x2^2 + y0^2
%  zI = ---------------------,  |zI|^2 = -------------
%           x1^2 + y0^2                   x1^2 + y0^2
%
  Xflt1 dup mul Yflt0 dup mul add dup  % X1^2+Y0^2 dup
 INFflt dup mul mul
  Xflt2 dup mul Yflt0 dup mul add lt   % X1^2+Y0^2 bool
  {pop INFflt dup} 
  {1. Xflt0 2 copy sub 3 1 roll add mul Yflt0 dup mul sub 1 index div
   Yflt0 2. mul 3 -1 roll div} ifelse
   /Yinv exch def /Xinv exch def
end
} bind

/G2MakeCurve4 {%  --> [x y x y ...]  CrvLen
20 dict begin % dict for G2Make_uvgk
   /dtmin     DTminCrv     def
   /precision CrvPrecision def

   /_TestDT {%  x y s g k t dt t2 x2 y2 g2 k2  --> .... OK
%/Test 12 Args
      %      --- Test 1: dt<dtmin
      5 index dtmin lt 
      {true}
      {%     --- Test 2: dk/dt
       dup 8 index sub abs dkmin le         % x y s g k t dt t2 x2 y2 g2 k2 OK1
       %     --- Test 3: Precision?
         { dup abs 8 index abs 2 copy lt {exch} if pop        %... dt t2 x2 y2 g2 k2 kmax     
           13 -2 roll 2 copy 15 2 roll                        %      ... x2 y2 g2 k2 kmax x y
           6 index 6 index XYsub dup mul exch dup mul add sqrt 2. div      % ... kmax h/2
%/dh2 1 Args
           dup 3 1 roll mul                                                %     c k*c   
           % check small angle: HalfChord < Radius/2 (ang < 60, sin(ang/2)< .5 )
           dup .5 lt
           { mul 2 div dup dup mul 2 div add precision lt}
           {pop pop false} ifelse
         }
         {false} ifelse                % x y s g k t dt t2 x2 y2 g2 k2 OK12
      } ifelse 
   } bind def

%   RB0 LB0 SetMobius
    1. G2Make_uvgk /kb ED pop pop pop

[  0. G2Make_uvgk dup /ka ED           % [x y g k
   dup kb sub abs 5. div  /dkmin ED
   0. 3 1 roll 0. 1. 1024. div         % [x y s g k t dt
 
   % Loop:
  {%                                   % [... x y s g k t dt(recommended)  
%/tdt 2 Args
    2 copy add dup 1. ge               % [... x y s g k t dt t2 t2>=1
    {pop pop 1. 1 index sub 1.} if     % [... x y s g k t dt t2


    dup G2Make_uvgk _TestDT            % [... x y s g k t dt t2 x2 y2 g2 k2 OK12
    {true}                             % [...                           ... 1st_attempt_OK
    {
      9{%
        pop pop pop pop pop 2 div 2 copy add
        dup G2Make_uvgk _TestDT        % [... x y s g k t dt t2 x2 y2 g2 k2 OK12
        {exit} if
       } repeat false                  % [... x y s g k t dt t2 x2 y2 g2 k2 1st_attempt_OK
     } ifelse

     9 -2 roll pop pop                 % [... x y s g dt t2 x2 y2 g2 k2 1st_attempt_OK
     7 -1 roll dup 3 -1 roll           % [... x y s g t2 x2 y2 g2 k2 dt dt 1st_attempt_OK
     {2.0000000 mul} if exch           % [... x y s g t2 x2 y2 g2 k2 dt_rec dt
     8 -1 roll 4 index add 2 div mul   % [... x y s t2 x2 y2 g2 k2 dt_rec ds
     8 -2 roll                         % [... x y x2 y2 g2 k2 dt_rec ds s t2
     4  1 roll add                     % [... x y x2 y2 g2 k2 t2 dt_rec s2
     5  1 roll                         % [... ... x2 y2 s2 g2 k2 t2 dt_rec 

     4 index LimitCrvLength gt {counttomark {pop} repeat 0 exit} if     
     1 index             1. ge {pop pop pop pop exit} if     
%     true {pop pop pop pop exit} if     
   } loop
   /crvlen exch def] crvlen
end
}

/G2MakeKS {%  --> [s0 k0 s1 k1  ... S kn]; fill /CrvLen in dict
20 dict begin % dict for G2Make_uvgk
   /dtmin DTminCrv 8 mul         def
   /precision CrvPrecision 5 mul def

   /_TestDT {%  x y s g k t dt t2 x2 y2 g2 k2  --> .... OK
      %      --- Test 1: dt<dtmin
      5 index dtmin lt 
      {true}
      {%     --- Test 2: dk/dt
        dup 8 index sub abs dkmin lt         % x y s g k t dt t2 x2 y2 g2 k2 OK1
       %     --- Test 3: Precision?
        { dup abs 8 index abs 2 copy lt {exch} if pop        %... dt t2 x2 y2 g2 k2 kmax     
          13 -2 roll 2 copy 15 2 roll                        %      ... x2 y2 g2 k2 kmax x y
          6 index 6 index XYsub dup mul exch dup mul add sqrt 2. div      % ... kmax h/2
          dup 3 1 roll mul                                                    %     c k*c   
          % check smalll angle: HalfChord < Radius/2 (ang < 60, sin(ang/2)< .5 )
          dup .5 lt
          { mul 2 div dup dup mul 2 div add CrvPrecision lt}
          {pop pop false} ifelse
        }
        {false} ifelse                  % x y s g k t dt t2 x2 y2 g2 k2 OK12
      } ifelse  
   } bind def

%    RB0 LB0 SetMobius
   1. G2Make_uvgk /kb ED pop pop pop
 
[  0. G2Make_uvgk dup /ka ED           % [x y g k
   dup kb sub abs 64. div  /dkmin ED
   0. 3 1 roll 0. 1. 512. div          % [x y s g k t dt
 
   % Loop:
  {%                                   % [... x y s g k t dt(recommended)  
%/tdt 2 Args
    2 copy add dup 1. ge               % [... x y s g k t dt t2 t2>=1
    {pop pop 1. 1 index sub 1.} if     % [... x y s g k t dt t2

    dup G2Make_uvgk _TestDT              % [... x y s g k t dt t2 x2 y2 g2 k2 OK12
    {true}                             % [...                           ... 1st_attempt_OK
    {
      5{%
        pop pop pop pop pop 2 div 2 copy add
        dup G2Make_uvgk _TestDT          % [... x y s g k t dt t2 x2 y2 g2 k2 OK12
        {exit} if
       } repeat false                  % [... x y s g k t dt t2 x2 y2 g2 k2 1st_attempt_OK
     } ifelse
     13 -2 roll pop pop 8 -1 roll pop  % [... s1 g1 k1 dt t2 x2 y2 g2 k2 1st_attempt_OK
      7 -1 roll dup 3 -1 roll          % [... s1 g1 k1 t2 x2 y2 g2 k2 dt dt 1st_attempt_OK 
     {2.000 mul} if exch               % [... s1 g1 k1 t2 x2 y2 g2 k2 dt_rec dt 

     9 -1 roll 4 index add 2 div mul   % [... s1 k1 t2 x2 y2 g2 k2 dt_rec ds
     8 index add                       % [... s1 k1 t2 x2 y2 g2 k2 dt_rec dt g1 snew
     4  1 roll                         % [... s1 k1 t2 x2 y2 s2 g2 k2 dt_rec 
     7 -1 roll exch                    % [... s1 k1 x y s g k t dt_recomended 
     1 index 1. ge {%
       pop pop exch pop                % [... s1 k1 x y s k
       4 2 roll pop pop exit
     } if     
   } loop
 end 
 ] 
% dup length /KSarrayLen 1 Args pop 
}

/G2CheckSpiral {%  --> bool
   JJ 1 eq {%
      NN 2 mul SinPhi dup mul mul 1 gt {%
      NN 2 mul Sin1 mul SinPhi mul Omega Nu sub cos sub        
      NN 2 mul Sin2 mul SinPhi mul Omega Nu add cos add
      2 copy exch  2 mul Sin1 mul SinPhi div 
             exch  2 mul Sin2 mul SinPhi div 
     [/TestSp1 4 2 roll] pop %==
      mul 0 ge
      } {false} ifelse
   }{
      NN 2 mul Omega Nu abs sub sin mul SinPhi abs mul Omega Nu abs add cos sub
          /TestSp2 1 Args
      0 le 
   } ifelse
}

/G2Phi2Xi {% Phi --> Xi  ;
  dup 0 eq {%
    pop Omega
  }{
%    CosSig CosPhi sub neg SinPhi mul SinSig SinPhi mul Atan180
     dup sin dup 0 ne {exch cos CosSig sub 1 index mul exch SinSig mul Atan180}
     {pop Omega exch 0 lt {90 add}{90 sub} ifelse         %  ???????????
     } ifelse 
  } ifelse
}

/G2SolveAll {% [phi array] ---> Fill solutions_array [ <<sol0>> <<sol1>> ] 
   [exch {%
      /NextPhi 1 Args 
      G2SolvePhi pop
   } forall]                     %/PreSolutions 1 Args
   [exch {G2FillSolution} forall] /Solutions 1 Args
   G2DataDict begin
     /Solutions ED
     /MaxCrvLen 2 
     Solutions {%
       /CrvLen get 2 copy lt {exch} if pop
     } forall def
   end
}

/G2SolvePhi{% phi --> dict1 dict2 count=0,1,2
20 dict begin
   dup abs Sigma lt {-1}{1} ifelse /JJ ED
   /SW 1 index 0 ge JJ -1 eq and {-1}{1} ifelse def   
   dup sin /SinPhi ED dup cos /CosPhi ED
   dup 2 div /Nu ED
   dup 0 lt {/Sgn -1 def} if
   dup 0 gt {/Sgn  1 def} if
   /Phi ED
   /Sin1 Omega Nu add sin def
   /Sin2 Omega Nu sub sin def
   Sin1 Sin2 2 copy mul -2 mul dup gA gB mul 2 mul sub /D3 ED /D2 ED
             dup mul exch dup mul add /D1 ED
   /D0 Phi Theta0 eq  Phi Theta0 neg eq or
    {0} {SinPhi SinSig mul dup mul 2 D2 mul gA mul gB mul add} ifelse def
%   [Sin1 Sin2 Sigma CosSig CosPhi] == 
   [D0 0 lt {%
     [(D1230, j) D1 D2 D3 D0 JJ] == 
     (Discriminant!) ==
   }{
     /DD0 D0 sqrt def
     D1 DD0 add JJ mul D2 D3 mul 2 mul div      % [N=N3 
     dup 0 le {== (N3negative) == stop} if  
     [ exch D0 0 eq {0}{-1} ifelse]             % [ [N3 Ntype] 
     JJ 1 eq D0 0 ne and {%
        .5 D1 DD0 add div                       % [N Ntype N1
        dup 0 le {== (N1negative) == stop} if
        [exch 1]
     } if
   } ifelse]                                    % [[N Ntype] [N Ntype]] 
   /Narray 1 Args
   /count 0 def
   {%                                           % next_N 
      aload pop /Ntype ED dup /NN ED
      dup SinPhi dup mul mul dup 0. gt {.5 JJ mul exch div} if /Rw ED
      sqrt dup SinPhi mul JJ -1 eq {neg}{abs} ifelse  % sqrt(N) w
      dup 0. eq {pop 0.} if                           % because WW 20 string cvs yields (-0.0)  
      /WW ED
      dup SinSig mul  JJ -1 eq {neg}{Sgn mul} ifelse /PW ED
          D2     mul  JJ +1 eq {neg  Sgn mul} if     /QW ED
      /IsSpiral G2CheckSpiral def
      
      %   Create dict if either it_is_spiral, or check_for_spirality_not_required
      CheckSpiral not IsSpiral or {%
          <</Phi Phi /PW PW  /QW  QW  /NN NN /JJ JJ 
            /Rw  Rw  /WW WW  /IsSpiral IsSpiral /Ntype Ntype>>  %dup Pdict
        (Accepted) ==
        /count count 1 add def
      } {
        (Rejected) ==
      } ifelse       % if IsSpiral        
   } forall
   count
   dup 2 eq {(Double solution) ==} if
end
}

/G2FillSolution {%  Solution_dict  ---> reject or update dict
dup begin
   /Sin1 Omega Phi 2 div add sin def
   /Sin2 Omega Phi 2 div sub sin def
   /LB0 Phi 2 div Gamma add JJ -1 eq {G2pm180} if def
   /RB0 gB gA div neg
        Sin2 Sin1 div mul
        NN 4 mul Sin1 dup mul mul JJ sub mul
        NN 4 mul Sin2 dup mul mul JJ sub div
        dup 0 le { /R0negative 1 Args pop 0 } if 
        sqrt Sin2 mul Sin1 div abs def
   /CoeffDict <<
      /CX0 -1. /CX1 1 PW add 2 mul /CX2 JJ 1 sub PW 2 mul sub
      /CY0  0. /CY1 2 QW mul       /CY2 1 index neg 
      /CW0  1. /CW1 WW 1 sub 2 mul /CW2 1 JJ add -2 WW mul add
   >> def
   /Xi Phi G2Phi2Xi def
   
   RB0 LB0 SetMobius
   /Spiral4 G2MakeCurve4 /CrvLen exch def def

   %JJ -1 eq RB0 1. eq and LB0 0 eq and { reject} if

   CrvLen 0 le {%
      %pop  --- DO NOT reject Solution dict
      G2DataDict begin /Nrejected Nrejected 1 add def end
   }{        
%     /CrvPlot G2MakeKS
      /CrvPlot {G2MakeKS} stopped {counttomark {pop} repeat [0 CrvA 2 CrvB] } if def
   } ifelse   
end
} def   

/G2_XYW {% t --> X Y W
   1. 1 index sub 2 copy dup mul 4 1 roll dup mul JJ mul 3 1 roll mul 2 mul %(1-t)^2 jt^2 2t(1-t)
   3 copy WW mul add add 4 1 roll          % W (1-t)^2 jt^2 2t(1-t)
   dup QW mul 5 1 roll                     % Y W (1-t)^2 jt^2  2t(1-t)
   PW mul add exch sub 3 1 roll            % X Y W
} bind

/G2_xy {% t --> x y
   G2_XYW
   dup 3 1 roll div 3 1 roll div exch      % x y
} bind

/G2_xyg {% t --> x y g
   dup G2_XYW dup 5 1 roll                               % W t X Y W
%   /WtXYW 5 Args
   div 4 1 roll 2 index div 4 1 roll                     % x y W t  
   JJ 1 sub PW 2 mul sub 1 index mul 1 add PW add 2 mul  % x y W t X'
   2 index div 3 1 roll                                  % x y  X'/W  W t
   1. 1 index 2. mul sub QW mul 2 mul                    % x y  X'/W  W t Y'
   2 index div 3 1 roll                                  % x y  X'/W  Y'/W W t
   JJ 1 add WW 2 mul sub mul WW 1 sub add 2 mul exch div % x y  X'/W  Y'/W  W'/W
   dup 3 1 roll 4 index mul sub 3 1 roll                 % x y  y'  X'/W  W'/W
                4 index mul sub                          % x y  y' x'
   dup mul exch dup mul add sqrt            
} bind

/G2SetBoxes {% 
  %  define /GivenBox and /NormBox entries in main dict
 G2DataDict begin GivenBox length 0 eq {%
  [[0   0 % include origin
    X1 X2 2 copy gt {exch} if Y1 Y2 2 copy gt {exch} if  % Xmin Xmax Ymin Ymax
    HalfChord 2 div dup dup dup                          % Xmin Xmax Ymin Ymax h h h h
    7 1 roll 5 1 roll 3 1 roll                           % Xmin h Xmax h Ymin h Ymax h
    add 7 1 roll sub 6 1 roll add 4 1 roll sub 4 1 roll
    GivenCurve aload pop
   ] MinMaxXY] G2SqBox /GivenBox exch def
 } if  
 [/GivenBox GivenBox] ==

 %  define /NormBox
NormBox length 0 eq {%
    gsave newpath
       BiarcData1 begin K1 Kdraw K2 Kdraw Kinf length 0 gt {Kinf Kdraw} if end
       BiarcData2 begin K1 Kdraw K2 Kdraw Kinf length 0 gt {Kinf Kdraw} if end
       0.05 setflat flattenpath  
       [[[{} {} {} {} pathforall] MinMaxXY 
         GivenCurve aload length 2 idiv {%
            Matrix transform G2neg counttomark 2 roll
         } repeat
         -2 dup neg dup
         -1 0 .5 Alpha Polar XYadd 1 0 .5 Beta Polar XYadd % to see unit tangents
        ] MinMaxXY
       ] G2SqBox 
       /NormBox exch def
    grestore
  } if
 [/NormBox NormBox] ==
end  
}

/G2SqBox {% Square given rectangular box (add 2%) --> [x1 y1 x2 y2]
 [ exch aload pop 4 copy 4 2 roll XYsub             % [x1 y1 x2 y2 x2-x1 y2-y1   
   2 copy lt {exch} if pop 1.02 mul 2 div 5 1 roll  % [dd x1 y1 x2 y2
   XYadd 2 div dup 3 index add 4 1 roll             % [y2' dd 2x0 y0
                   2 index sub 4 1 roll 2 div exch  % [y1' y2' x0 dd
                   2 copy sub  5 1 roll             % [x1' y1' y2' x0 dd  
                   add exch]
}

/Ashow {% [... str1 str_with_ind ifgreek]
%/Ash 1 Args 
gsave  
  [exch aload pop
  {/Symbol findfont 14 scalefont setfont} if
  Ishow
  counttomark {show} repeat pop
  currentpoint
grestore moveto
} bind 

/G2show {% (string)/[array]  (currentpoint context)
%/G2show1 1 Args
  dup type /stringtype eq {show}{Ashow} ifelse
} 

/G2show1 {% (string)/[array]
%/G2show1 1 Args
  G2DataDict /Ytext Ytext BaseLineSkip sub put
  Indent Ytext moveto G2show
} 

/G2show2 {% (string)
%/G2show2 1 Args
    XpageMax 2 div 10 add Ytext moveto G2show
}

/G2Code {% key_str value --> string
   [3 1 roll 20 string cvs ( = ) 3 -1 roll false]
} bind

/G2CodeDeg {% key_str value(degrees) --> array
   [3 1 roll 20 string cvs (\260) AppStr ( = ) 3 -1 roll true]
} bind

/G2Kdraw {% [x y tau k]
   dup 3 get abs 800 Picmm mul 1 lt {
      %  R > 800 mm
      [exch 4 Kload 100 Picmm 1 index mul abs Radian mul dup 0 eq {pop pop 0 100 Picmm} if] 
   } if Kdraw
} bind

/PageStart {%  (Title)
/Pstart 1 Args
%   /Helvetica findfont 12 scalefont setfont
 G2DataDict begin
   /ThisPage ThisPage 1 add def
   /Ytext YpageMax BaseLineSkip sub def
   Margin dup translate 0 setlinewidth 
   Indent Ytext moveto show
   (Page ) ThisPage 4 string cvs AppStr ( / ) AppStr TotalPages  4 string cvs AppStr
   XpageMax Indent sub Ytext moveto 
   1 0 set_text show %Tclean show
   () G2show2
   0 0 XpageMax YpageMax 4 copy rectstroke rectclip newpath
 end   
} bind 

/GivenDataPic {%
 BeginFig
   %GivenBox dup dup 2 get exch 0 get sub XpageMax exch div PicBegin
   GivenBox dup aload pop 4 2 roll XYsub 1.25 div 2 copy lt {exch} if pop XpageMax exch div
   PicBegin
   /T 12 PicFont
   .6 PicLW (x) (y) PicAxes
   .8 PicLW X1 Y1 moveto X0 Y0 l^ X2 Y2 lineto stroke
   X1 Y1 2 copy moveto 4 Rpoint 20 Picmm Tau1 Polar rl^
   moveto 3 Picmm Tau1 90 Crv1 0. le {neg} if add Polar rmoveto (A) .5 .5 set_text show
   X2 Y2 2 copy moveto 4 Rpoint 20 Picmm Tau2 Polar rl^ 
   moveto 3 Picmm Tau2 90 Crv2 0. le {neg} if add Polar rmoveto (B) .5 .5 set_text show
   stroke
   % No dash for circles of too small radius (R < 2 Picmm):
   [2. Picmm Crv1 mul abs 1. lt {1.5 Picmm dup} if] 0 setdash
     [X1 Y1 Tau1 Crv1] G2Kdraw stroke
   [2. Picmm Crv2 mul abs 1. lt {1.5 Picmm dup} if] 0 setdash
     [X2 Y2 Tau2 Crv2] G2Kdraw stroke
   [] 0 setdash

   gsave
      1.2 PicLW 
      Solutions {%
         begin  
           Phi 0 eq {Red2 .4 PicLW} {Green .2 PicLW} ifelse
           CrvLen 0 gt {%
             Spiral4 aload length 2 idiv 1 sub 3 1 roll
                 G2neg Matrix itransform moveto
                {G2neg Matrix itransform lineto} repeat stroke 
           } if 
         end
      } forall
   grestore

   GivenCurve length 0 gt {%
      Red2 .4 PicLW %3 PicLW 4 Dotted GivenCurve XYdraw stroke
      GivenCurve aload length 2 idiv {moveto -3.6 Rpoint} repeat
   } if 

 EndFig
}

/G2Output {%
   /OutputFile OutputFile (w) file def
   OutputFile (\% c= ) HalfChord 12 string cvs AppStr writestring
   Solutions {%
      begin %------------
      OutputFile (\n\% Phi: ) Phi 10 string cvs AppStr
                 (  Length: ) AppStr CrvLen OutputN not {HalfChord mul} if 
                 12 string cvs AppStr writestring

      OutputFile dup (\n[) writestring 0     % file count

      0 2 Spiral4 length 1 sub {
         dup 8 mod 0 eq {%                   % file count i
            2 index (\n) writestring
         } if
         Spiral4 exch 2 copy get 3 1 roll 1 add get             % file count x y
         OutputN not {G2neg Matrix itransform} if  exch         % file count y x 
         3 index exch 12 string cvs ( ) exch AppStr writestring % file count y
         2 index exch 12 string cvs ( ) exch AppStr writestring % file count
      } for
      pop (\n]\n) writestring                % 
      end    %------------
   } forall
   OutputFile closefile
}

/GivenDataPage {%   // GivenDataString  from WorkDict
 gsave
%   ErrCode 0 gt {Red} if
   Title length 0 eq {(Given data: )}{Title} ifelse  PageStart
   GivenDataString G2show1

   Black
   Comment length 0 gt {Comment G2show1} if  
%   (X_1|) X1 G2Code G2show1       (X_2|) X2 G2Code G2show2
%   (Y_1|) Y1 G2Code G2show1       (Y_2|) Y2 G2Code G2show2
   (X1) X1 G2Code G2show1 (,  ) show (Y1) Y1 G2Code G2show
   (X2) X2 G2Code G2show2 (,  ) show (Y2) Y2 G2Code G2show (,  ) show
   (c) HalfChord G2Code G2show
   (t1) Tau1 G2CodeDeg G2show1  (t2) Tau2 G2CodeDeg G2show2
   (k1) Crv1 G2Code G2show1 (,  ) G2show (g1) gA G2Code G2show
   (k2) Crv2 G2Code G2show2 (,  ) G2show (g2) gB G2Code G2show
   Q 0 ge {Red} if 
   (Q)   Q  G2Code G2show1 Black (,   ) show 
   Sigma abs 180 gt {Red}{Black} ifelse (s) Sigma G2CodeDeg G2show
   Black (;   ) show 
   Solutions length 3 string cvs ( solutions found for ) AppStr
   Ngiven 4 string cvs AppStr ( values of parameter. ) AppStr show
   (F) PhiMin  G2CodeDeg G2show1
%/G2RJtext %  --> (text)
   Nrejected 0 gt {
      Red2
      Nrejected dup 5 string cvs ( solution) AppStr exch 1 ne {(s) AppStr} if
      ( rejected: curve length > ) AppStr LimitCrvLength 20 string cvs AppStr
      G2show1  
   } if 
   CheckSpiral not {Blue (No spirality test!) G2show1} if
   Fname length 0 gt {%
     (Input from: ) G2show1 Fname G2show
   } if  

   OutputFile length 0 gt {%
     (Output to: ) G2show1  OutputFile G2show
   } if  

   Black

   G2SetBoxes
   GivenDataPic 
   OutputFile length 0 gt {G2Output} if
 grestore
}

/G2ErrorPage {%   // using  GivenDataString  from WorkDict
 gsave
   Red 
%   (Error ) ErrCode 5 string cvs AppStr  PageStart
   (Error )  PageStart
   GivenDataString G2show1
   Comment         G2show1
 grestore
}

/G2ShowGivenCurve {% Show given curve in normalized position
 gsave
 Red2 .4 PicLW
   GivenCurve aload length 2 idiv {%
         Matrix transform G2neg moveto -3.6 Rpoint
   } repeat
 grestore  
}

/G2GivenCrvPlot {% Show given curvature plot (normalized)
                 % Kmag is set in outer dictionary 
   gsave Blue .4 PicLW 
     GivenCrvPlot aload length 2 idiv {Kmag mul G2neg moveto -3.4 Rpoint} repeat
   grestore  
}
  
/G2DataShowNorm {
   -1 0 moveto 3 Rpoint 1 0 moveto 3 Rpoint
   gsave Blue
      1 PicLW
     -1 0 moveto 15 Picmm Alpha Polar rl^
      1 0 moveto 15 Picmm Beta  Polar rl^ stroke
     [1.5 Picmm dup] 0 setdash
     % No dash for circles of too small radius (R < 2 Picmm):
     [1. Picmm CrvA mul abs 1. lt {1.5 Picmm dup} if] 0 setdash  [-1 0 Alpha CrvA] G2Kdraw stroke
     [1. Picmm CrvB mul abs 1. lt {1.5 Picmm dup} if] 0 setdash  [ 1 0 Beta  CrvB] G2Kdraw stroke
     [] 0 setdash
     G2ShowGivenCurve
   grestore
}

/G2Locus {%
    Sigma 179.9 lt {%
    gsave Brown       
      0 0 moveto 2 Sigma 2 div Polar rl^ stroke 
      SinSig 25 div Radian mul 2 div        % 2eps=  Asin (SinSig/R^2)
      [ exch dup Omega 90 sub add exch      % [ Xi1 eps
       Omega exch sub 40 forfor {%
          dup -2 mul Sigma add sin SinSig exch div sqrt exch Polar
      } for ] dup XYdraw stroke 180 rotate XYdraw stroke
      [2 Picmm dup] 1 Picmm setdash 180 rotate
      3 {90 rotate  0 0 moveto 3 Sigma 2 div Polar rl^ stroke} repeat
    grestore
    } if
}

/NormalDataPic {%
   gsave PicPath clip newpath .9 setgray
      0 0 moveto 0 0 2 Omega Theta0 G2Phi2Xi arcn 0 0 lineto closepath fill
   grestore 
   /T 12 PicFont
   .6 PicLW (x) (y) PicAxes
   Sigma 90 gt {1 0 moveto 0 4 rlineto -1 0 moveto 0 -4 rlineto stroke} if
   Sigma 90 lt {0 0 1 -180 0 arc stroke} if
   G2DataShowNorm
   gsave PicPath clip newpath
%      Sigma abs 90 lt {0 0 moveto 3 XiLim Polar rl^ stroke} if
      G2Locus
%      .2 PicLW Black
%      XIs {dup -2 mul Sigma add sin dup abs 0.01 lt  %                % Xi Sin2 bool
%            {pop SinSig} if SinSig exch div sqrt exch Polar 0 0 moveto rlineto
%          } forall stroke
      .6 PicLW Brown 0 0 moveto 2. Sigma 2 div Polar rl^ stroke   % to G2Locus?
      .4 PicLW Green
      PhiArray {%
        dup sin dup 0 eq {pop 0.05} if exch cos   % sinphi cosphi
        SinSig 2 index div 3 1 roll
        CosSig sub exch div moveto -4 Rpoint
      } forall
      
      1000   0             %/PhiPrev 1000 def /id 0 def
      Solutions {%
         begin
           1 add dup 4 string cvs                        % prev count (ID)
           Phi dup 5 1 roll 4 -1 roll eq                 % phi count  ID bool
%  "double" solutions got with:   /UserG2Data [/LogSpir2 30 40] /UserPhiData 10
           {(*) AppStr} if /ID exch def                  % phi count 
           [IsSpiral not {1 Picmm dup} if] 0 setdash
           0 PicLW
           0 0 moveto WW 0 eq 
             {PW neg QW neg}
             {PW WW div QW WW div} 
           ifelse lineto currentpoint stroke              
           .6 PicLW [] 0 setdash           
           Ntype currentlinewidth mul Xi Polar XYadd moveto
           4 IsSpiral not {neg} if Rpoint
%          Phi PhiPrev eq {2 copy .2 Xi Polar XYadd}{0 0} ifelse moveto l^
         end
      } forall pop pop
   grestore 
}

/NormalDataPage {%
 gsave
   (Normalized data) WasDecreasing {(  (converted to incr. curvature):)}{(:)} ifelse
      AppStr PageStart
   (a) Alpha G2CodeDeg  G2show1  (b) Beta G2CodeDeg G2show2
   (a) CrvA G2Code G2show1 (,  ) G2show (g1) gA G2Code G2show
   (b) CrvB G2Code G2show2 (,  ) G2show (g2) gA G2Code G2show
   (Q) Q    G2Code G2show1  (,   ) show
   (s) Sigma G2CodeDeg G2show (;   ) show
   %TODO  "4+1 solutions found ..."
   Solutions length 3 string cvs ( solutions.) AppStr G2show

   BeginFig
   NormBox  dup dup 2 get exch 0 get sub XpageMax exch div PicBegin
   NormalDataPic 
   EndFig
 grestore
}

/G2CrvProfile {% 
  [CrvPlot dup 1 get exch GetLast CrvA CrvB 0] MinMax   % Kmin Kmax
  2 copy sub -10 div dup 3 1 roll add 3 1 roll sub      % Kmax Kmin
  2 copy sub CrvLen 1.1 mul .25 mul exch div /Kmag ED 
  [CrvLen -.05 mul 3 -1 roll Kmag mul CrvLen 1.05 mul 5 -1 roll Kmag mul]
  XpageMax CrvLen 1.1 mul div
  PicBegin
  /T 12 PicFont
  .2 PicLW PicPath stroke
  .6 PicLW (s ) (.k) PicAxes
  CrvLen 0 moveto 1.2 Rpoint CrvLen -2 Format .5 -.2 set_text show
  Black .6 PicLW
  CrvPlot aload length 2 idiv 1 sub 3 1 roll 
  Kmag mul moveto {Kmag mul lineto} repeat stroke
  0 CrvA Kmag mul moveto 0 CrvB Kmag mul l^ stroke 
  .4 PicLW [1 Picmm dup] 0 setdash
  0 CrvA Kmag mul moveto CrvLen 0 rlineto
  0 CrvB Kmag mul moveto CrvLen 0 rlineto stroke
  G2GivenCrvPlot       %  currentdict /Kmag undef
} 

/G2ShowConic {%  bool
gsave
9 dict begin
   dup
   { {XYdraw stroke}}
   {/PW PW neg def /QW QW neg def /WW WW neg def
     {counttomark 2 idiv {moveto 2 Rpoint} repeat pop}
   } ifelse
   /Draw exch def 
   Brown .2 PicLW
   { -1 0 moveto  WW 0 eq 
        {99 Omega Polar lineto}
        {PW WW div QW WW div lineto 4 Rpoint } ifelse
     1 0 lineto stroke
   } if  
  /ds 2 Picmm def %10 PicDict /PicScal get div def
  /RR 1 NormBox {abs 2 copy le {exch} if pop} forall dup mul def
  1 PicLW Maroon
  JJ -1 eq {%
     [ 0. {%                                                 % [ t 
       dup G2_xyg                                            % [ t x y g
       3 copy 0.0000001 lt 3 1 roll dup mul exch dup mul add % [ t x y g bool x^2+y^2  
       RR gt or {pop 3 -1 roll pop exit} if
       4 -1 roll ds                              % [ x y x y ... x y g t ds
       3 -1 roll div add
   } loop Draw
     [ 1. {%                                                 % [ t 
       dup G2_xyg                                            % [ t x y g
       3 copy 0.0000001 lt 3 1 roll dup mul exch dup mul add % [ t x y g bool x^2+y^2  
       RR gt or {pop 3 -1 roll pop exit} if
       4 -1 roll ds                              % [ x y x y ... x y g t ds
       3 -1 roll div sub
   } loop Draw
  }{%  JJ = 1   
      [0. 1. 20 forfor {G2_xy} for 1 0 Draw
  } ifelse
%     1 PicLW
%    -1 0 moveto 20 Picmm Acon Polar rl^
%     1 0 moveto 20 Picmm Bcon Polar rl^ stroke
grestore
end
}

/SolutionPic {%
   /T 12 PicFont
   .6 PicLW (x) (y) PicAxes
%  G2DataShowNorm
   ShowConic { 
      Red2
      Rw 1 gt {Red 0 0 1 0 360 arc stroke} if
      Rw   1 le Rw 0 gt and
      Rw -90 ge Rw 0 lt and  or {
         Rw 1 sub 0 Rw abs 0 360 arc stroke 1 Rw sub 0 Rw abs 0 360 arc stroke
      } if
      true   G2ShowConic
      false  G2ShowConic
   } if   
   CrvLen 0 gt {Black 1.2 PicLW Spiral4 XYdraw stroke} if
   G2ShowGivenCurve
}

/SolutionPage {%    Solution dictionary is loaded
 RB0 LB0 SetMobius
 gsave        
   (Solution ) ID AppStr IsSpiral not {(   (not spiral)) AppStr} if
   PageStart
   (a) Alpha G2CodeDeg G2show1 (,  ) show
   (b) Beta  G2CodeDeg G2show  (,  ) show
   (s) Sigma G2CodeDeg G2show
   (a) CrvA  G2Code    G2show2 (,  ) show (b)  CrvB  G2Code G2show
   (j) Phi G2CodeDeg   G2show1 ( / ) show (x) Xi G2CodeDeg G2show
   (/,  ) show (w) WW G2Code G2show (,  ) show
   Rw 0 ne {(rw) Rw G2Code G2show (,  ) show} if
   WW 0 ne {(p) PW WW div G2Code G2show (,  ) show (q) QW WW div G2Code G2show } if    
   (r0) RB0 G2Code G2show1 (l0) (,  ) show LB0 G2CodeDeg G2show
   CrvLen 0 gt {%
      (L) CrvLen G2Code G2show2 ( * ) show HalfChord 12 string cvs show ( = ) show
      CrvLen HalfChord mul 12 string cvs show
   }{(Curve too long!) G2show2} ifelse
%   IsSpiral not {(Not a spiral!) G2show1 () G2show2} if 
   BeginFig
   gsave
      [[NormBox aload pop -1.1 dup 1.1 dup   % because NormBox may be empty
      %  ShowConic --- add Xinv Yinv
      ] MinMaxXY ] G2SqBox
      % NormBox
      /NewBox 1 Args
      dup dup 2 get exch 0 get sub XpageMax exch div PicBegin 
      PicPath  clip newpath
      SolutionPic
      Red Xinv Yinv moveto -5 Rcross %10 Rpoint 
   grestore   
   EndFig
   
   0 XpageMax translate
   BeginFig
     CrvLen 0 gt {G2CrvProfile} if
   EndFig
 grestore
}

/AllSolutionsPage {%
 gsave
   (All Solutions) ( \() AppStr Solutions length 4 string cvs AppStr (\)) AppStr PageStart
   (a) Alpha G2CodeDeg G2show1  (b) Beta  G2CodeDeg G2show2
   (   ) show                   (s) Sigma G2CodeDeg G2show
   (a) CrvA  G2Code    G2show1  (b) CrvB G2Code    G2show2
   CheckSpiral not {Blue (No spirality test!) G2show1} if
   BeginFig
   gsave
      NormBox dup dup 2 get exch 0 get sub XpageMax exch div PicBegin
      /T 12 PicFont
      .6 PicLW (x) (y) PicAxes
      G2DataShowNorm
      gsave
         0 .85 .85 setrgbcolor
         BiarcDict begin BiarcData1 BiarcDraw stroke BiarcData2 BiarcDraw stroke end
         stroke
      grestore
      newpath
%    gsave 0 .2 .2 setrgbcolor closepath fill grestore
     %stroke
      1.2 PicLW 
      Solutions {%
         begin  
           Phi 0 eq {Red2 .4 PicLW} {Black .2 PicLW} ifelse
           CrvLen 0 gt {Spiral4 XYdraw stroke} if 
         end
      } forall
      G2ShowGivenCurve
   grestore   
   EndFig
   0 XpageMax 1 mul translate
   BeginFig

   [CrvA CrvB 0] MinMax   % Kmin Kmax
   2 copy sub -10 div dup 3 1 roll add 3 1 roll sub      % Kmax Kmin
   2 copy sub MaxCrvLen 1.1 mul .25 mul exch div /Kmag ED 
   [MaxCrvLen -.05 mul 3 -1 roll Kmag mul MaxCrvLen 1.05 mul 5 -1 roll Kmag mul]
   XpageMax MaxCrvLen 1.1 mul div  PicBegin
    /T 12 PicFont
    .2 PicLW PicPath stroke
    .6 PicLW (.s) (.k) PicAxes
    MaxCrvLen dup 0 moveto 2 Rcross -3 Format .5 -.2 set_text show
    Red .2 PicLW
    Solutions {%
      begin
        Phi 0 eq {Red2 .4 PicLW} {Red .2 PicLW} ifelse
        CrvLen 0 gt {%
        CrvPlot aload length 2 idiv 1 sub 3 1 roll 
        Kmag mul moveto {Kmag mul lineto} repeat stroke
        } if   
      end
    } forall     
    G2GivenCrvPlot
    .6 PicLW [1 Picmm dup] 0 setdash
    0 CrvA Kmag mul moveto MaxCrvLen 0 rlineto
    0 CrvB Kmag mul moveto MaxCrvLen 0 rlineto stroke

  EndFig
 grestore
}

/CubicPage {%
 gsave
   (Search for Cubic Solution ) PageStart

   /Fmin 0 def /Fmax 0 def
   /XiF [Solutions {%
      dup /Xi get exch /Fxy3 get /XiF 2 Args
      %CubeRoot
      dup Fmin lt {dup /Fmin ED} if        %Xi_i F_i
      dup Fmax gt {dup /Fmax ED} if
   } forall] def 
   /Mag Fmax Fmin abs 2 copy lt {exch} if pop 182 exch div def
   /XiRef Sigma 2 div def /Xi1 XiRef 180 sub def /Xi2 XiRef 180 add def
   BeginFig
   %[-190 -190 190 190] XpageMax 380 div PicBegin
    [Xi1 -180 Xi2 180] XpageMax 362 div PicBegin
   .6 PicLW ( ) (F) PicAxes
   XiF aload length 2 idiv {
      Mag mul exch dup Xi1 lt {360 add} if dup Xi2 gt {360 sub} if  exch moveto 2 Rpoint
   } repeat 

   0.2 PicLW 
   -180 90 190 {0 moveto 4 Rcross} for XiRef 0 moveto 6 Rcross
   EndFig
 grestore
}

/G2pm180 {dup 0 le {180 add}{180 sub} ifelse} bind

/G2Vogt {%                            working within G2DataDict
   /WasDecreasing Crv1 Crv2 gt def
   /G2neg WasDecreasing {{neg}}{{}} ifelse bind def
   /CrvA Crv1 HalfChord mul G2neg dup abs 0.0001 lt {pop 0. /Crv1 0. def} if def
   /CrvB Crv2 HalfChord mul G2neg dup abs 0.0001 lt {pop 0. /Crv2 0. def} if def
   /Alpha Tau1 Mu sub G2neg Upd180 def  
   /Beta  Tau2 Mu sub G2neg Upd180 def
   /Normalized X1 -1. eq Y1 0. eq and X2 1. eq and Y2 0. eq and def

   BiarcDict begin
      Alpha Beta CrvA 1 MakeBiarc << BiarcData {} forall >> % dict1 
      Alpha Beta CrvB 2 MakeBiarc << BiarcData {} forall >> % dict2
   end               /BiarcData2 ED  /BiarcData1 ED
   Alpha Beta 2 copy sub 2 div 3 1 roll add dup 0 le {%  gamma A+B
     360 add exch G2pm180 exch
   } if                                          % gamma sigma  
   dup /Sigma ED 2 div /Omega ED /Gamma ED       % sin omega instead of /IsLong
   % corrected for Biarc, possibly wrong:
   % /Alpha Omega Gamma add def  /Beta Omega Gamma sub def  
   /SinSig Sigma sin def /CosSig Sigma cos def 
   CrvA Alpha sin add CrvB Beta sin sub 2 copy
   /gB ED /gA ED mul Omega sin dup mul add /Q ED
   [/SigmaQ: Sigma Q] ==
   /Theta0 Q 0 lt {
     gA gB mul                                            % gg
     dup 2 mul CosSig mul SinSig dup mul add  exch        % numerator gg
     dup 2 CosSig mul SinSig dup mul mul add 1 index mul SinSig dup mul dup mul add
     sqrt sub div %/CosTheta0 1 Args
     Acos} {0} ifelse   Pdef
     /PhiMin Theta0 90 MIN 180 Sigma sub MIN Pdef
}

/G2StoreCrvPlot {% [s0 k0 s1 k1 ...], length > 0 
   dup length /_n0 exch def dup 0 get  /_s0 exch def
   [exch aload length 2 idiv {%
       HalfChord mul exch _s0 sub HalfChord div exch _n0 2 roll
   } repeat ] G2DataDict  /GivenCrvPlot 3 -1 roll put
} 

/G2SetPhiArray {%  --> [phi-i]
% old:
%      /UserPhiData [UserXiData {%
%        dup Sigma sub cos 1 index cos div dup abs 1 gt
%        {pop pop} {Acos exch abs 90 gt {neg} if} ifelse
%      } forall] def

G2DataDict begin
  currentdict /UserPhiData known not {/UserPhiData [] def} if

  UserPhiData dup type 1 {% 1 is repeat count     % UserPhiData /type
     dup /arraytype eq {% 
        1 index length 0 gt {pop exit} if         
        % otherwise continue, treat empty array  
     } if
     dup /arraytype eq {         %    // empty array 
        pop pop 0                % 
        PhiMin  0. gt {pop 1} if 
        PhiMin  5. gt {pop 2} if 
        PhiMin 15. ge {pop 4} if 
        PhiMin 45. ge {pop 5} if % {pop PhiMin 5 div round cvi} if 
/Npt 1 Args
        /integertype
     } if
     dup /integertype eq {
        pop                                        % N
        PhiMin 2 mul floor 1 index 2 mul 1 add div % N step
        /dphi ED                                   % N
        % Look for a proper step delta_phi (integer, half-integer, ... int/10)
        % such that d_phi = p/q, and there were integer p between
        % q1=q*PhiNax/(N+1) and q2=q*PhiNax/N.    
        PhiMin 1 index 1 add div PhiMin 2 index div   % N Q1 Q2
        [1 2 4 5 10] {/q ED
           2 copy q mul floor exch q mul ceiling exch % N Q1 Q2 q*Q1 q*Q2
           1 index ge  {                              % N Q1 Q2 q*Q1 //q*Q2=q*Q1 
              q div /dphi exch Pdef exit
           } {pop} ifelse
        } forall pop pop                           % N
        [PhiMin neg 3 -1 roll neg                  % [ -Th0 -N
        1 1 index neg {dphi mul} for PhiMin]       % [ phi1 2 3 ... ]   
        exit
     } if
     dup /realtype eq {                            % step /type
        pop                                        % step
        dup /dphi ED PhiMin exch div floor cvi neg % -N
        [exch 1 1 index neg {dphi mul} for]
        exit
     } if
     pop pop [0.] 
     /Comment Comment (Incorrect /UserPhiData; show default data. ) AppStr def
   } repeat
   /PhiArray 1 Args 
   [exch {%   replace special values +-999 by exactly +-PhiMin
       dup -999 eq {pop PhiMin neg} if dup 999 eq {pop PhiMin} if
       dup abs PhiMin gt {pop} if
   }  forall counttomark 0 eq {0.} if
   ] dup length
end
/Ngiven ED         % to print on the title page
}
>> def  % end of G2HermiteDict

(G2HermiteDict ok) ==

%
%  Methods to treat user data
%
/G2InpDict <<

% Every /Method: eats its arguments;
%                returns 0 or positive ErrorCode
%                calls XYTK8
%                stores GiveCurve (if any)
% ---------                                         NOT YET !!!     

/ABpp4 {%  private: alpha0 beta0 p1 p2
5 dict begin
  /p2 ED /p1 ED 2 copy add 2. div sin /somg ED /beta ED /alpha ED
  p1 p2 mul 0. gt {
     alpha dup neg sin somg p1 div sub
     beta  dup     sub somg p2 mul add
     Norm4
  } {101} ifelse
end
} 

/Conc2 {% r2 phi                               % Concentric 
/Conc2 2 Args
   [ 2 index abs dup 1 lt {pop 1.} if 1.1 mul dup dup neg dup 4 2 roll] 
    G2DataDict /GivenBox 3 -1 roll put         % r2 phi
   1. 0 90. 1.   6 -2 roll 2 copy Polar        % 1. 0 90. 1. r2 phi X2 y2  
   4 2 roll 90 add 1. 3 -1 roll div
   XYTK8
}

/Ell2 {% a b                                    % ellipse
5 dict begin /b ED /a ED                           % 
     a 0 90 b 0 lt {neg} if      a b div b abs div 
     0 b a 0 gt {180}{0} ifelse  b a div a abs div
     % TODO: step not properly selected ?
     [0 5 90 {dup cos a mul exch sin b mul} for]     % [given curve] 
     G2DataDict /GivenCurve 3 -1 roll put
end
XYTK8 
} 

/Parab3 {% a x1 x2,   y=sqrt(ax)                     % parabola
9 dict begin /x2 ED /x1 ED dup /a ED sqrt /sa ED                  % 
  x1 dup a mul sqrt a sqrt 2 index sqrt 2. mul Atan90 a sqrt -4 div a 4 div x1 add 1.5 exp div
  x2 dup a mul sqrt a sqrt 2 index sqrt 2. mul Atan90 a sqrt -4 div a 4 div x2 add 1.5 exp div
  XYTK8 
     % TODO: step not properly selected
  % s(x) = sqrt[x*(4x+a)]/2 +a[ln(a+8x+4sqrt[...])-ln(a)]/8
  % k(x) = -2sqrt(a)/(4x^1)^(3/2)
     [x1 x2 13 forforall {dup a mul sqrt} forall]     % [given curve] 
     G2DataDict /GivenCurve 3 -1 roll put
     /s1 x1
       dup 4. mul a add sqrt /tmp ED sqrt /sx ED       % x  //tmp = sqrt(4x+a)
       sx tmp mul 2 div sx 2. mul tmp add sa div ln 2. mul a mul 8. div add % s
     def
     [x1 x2 13 forforall {%
       dup 4. mul a add sqrt /tmp ED sqrt /sx ED       % x  //tmp = sqrt(4x+a)
       sx tmp mul 2 div sx 2. mul tmp add sa div ln 2. mul a mul 8. div add % s
       s1 sub    -2 sa mul tmp div tmp div tmp div     % s-s1 k
     } forall] G2StoreCrvPlot
end
} 

/Cornu3 {% S1 S2 Mag:  Cornu,  k(s) = s/Mag 
/Cornu3: 3 Args
FresnelDict   begin
                                                % s1 s2 Mag
  pop /Mag 1 def   %%%% 2 div  /Mag ED          % because my Fresnel corresponds to k=s/2    
                                                % TODO: step not properly selected
  2 copy
  [ 3 1 roll exch dup                           % s1 s2 [s2 s1 s1
  Fresnel Mag mul 4 1 roll Mag mul 4 1 roll     % s1 s2 [x1 y1 s2 s1 
  2 div dup dup mul Radian mul 3 1 roll         % s1 s2 [x1 y1 Tau1 s2 s1/2
  Mag div exch                                  % s1 s2 [x1 y1 Tau1 k1 s2
  dup Fresnel Mag mul 3 1 roll Mag mul 3 1 roll % s1 s2 [x1 y1 Tau1 k1 x2 y2 s2
  2 div dup dup mul Radian mul exch             % s1 s2 [x1 y1 Tau1 k1 x2 y2 Taus s2/2 
  Mag div
  ] 3 1 roll                                    % [8] s1 s2

  2 copy
  [ 3 1 roll 30 forforall {Fresnel Mag mul exch Mag mul exch} forall]
  G2DataDict /GivenCurve 3 -1 roll put
end

3 -1 roll aload pop XYTK8                      % s1 s2 
[ 3 1 roll 30 forforall {dup 2 div} forall] G2StoreCrvPlot
} 

/LogSpir2 {% nu phi                            % LogSpiral
6 dict begin
   abs /phi ED abs dup /nu ED dup sin /Snu ED cos /Cnu ED
   Snu 0. ne Cnu 0. ne and {
      /Cot Cnu Snu div def
      /S1 1.                         Cnu div def
      /S2 phi Radian div Cot mul Exp Cnu div def
      /Npt S2 S1 sub HalfChord div 10 mul round cvi def
      1 0 nu Snu  
      phi Radian div Cot mul Exp dup phi Polar nu phi add  % x1 y1 t1 k1 r2 x2 y2 t2
      Snu 5 -1 roll div XYTK8
      G2DataDict /GivenCurve  [S1 S2 Npt forforall {%
         Cnu mul dup        % r r
         ln Cot div Radian mul Polar
      } forall] put

      [S1 S2 Npt forforall {%
         dup S1 sub 1. 3 -1 roll div Cot div 
      } forall] G2StoreCrvPlot
   } { 7} ifelse   
end
}

/Norm4 {%  [/Norm4 alpha0 a beta0 b ]
/Norm4 4 Args
 G2DataDict begin
    /X1 -1 def /Y1 0 def /X2 1 def /Y2 0 def
    /Normalized true def /HalfChord 1 def         % alpha a beta b
    4 copy /Crv2 ED /Tau2 ED /Crv1 ED /Tau1 ED
    /CrvB ED /Beta ED /CrvA ED /Alpha ED 
    /Matrix [1 0 0 1 0 0] def
    G2Vogt
 end 
} 

/XYTK8 {%  Store G2 Hermite data in G2DataDict
 /XYTK8: 8 Args
 G2DataDict begin                                      % K1 K2
   /Crv2 ED /Tau2 ED /Y2 ED /X2 ED 
   /Crv1 ED /Tau1 ED /Y1 ED /X1 ED
   X1 Y1 X2 Y2 
   4 copy XYsub abs exch abs MAX 0.0001 lt {
      (P1 = P2) == Error_Not_Coded
   } {
      LocalXY   /Y0 ED /X0 ED 
      /Mu ED /HalfChord ED                                % Check Mu undefined
      /Matrix [Mu cos HalfChord div
               Mu sin HalfChord div dup neg exch 2 index  % cos -sin sin cos
               4 copy X0 mul exch Y0 mul add neg 3 1 roll % ...              tx cos -sin
                      X0 mul exch Y0 mul add neg] def
      %/Matrix 6 array identmatrix def                
      G2Vogt
   } ifelse
 end  % pop G2DataDict
}

>> def

%  Some options (edit at your own risk):
/G2Options <<
  /Margin          30
  /Title          ()       %  not yet...
  /ShowConic      false
%  /ShowXiPage    true 
%  /AddUniversal  true 
  /BlackWhite    false
% /ShowCrvPage   false
  /CheckSpiral   true                  % test with false
  /BaseLineSkip  20
  /Indent        10
  /DTminCrv     1. 1024. div 1024. div      
  /CrvPrecision 0.002                  
  /FindCubic    false
  /ShowBilens false
  /ShowAll    true
  /LimitCrvLength 5000. 
>> def

%---------------------------------------------------------------
/G2DataDict <<
  /XpageMax 595 /YpageMax 842 /Ytext 0         /ThisPage 0
  /Ngiven 0 /Nrejected 0
  /X1 -1. /Y1 0.  /X2 1. /Y2 0. /HalfChord 1.  
  /WasDecreasing false    /Normalized false
  [/Tau1 /Crv1 /Tau2 /Crv2
   /X0 /Y0 /Mu
   /Alpha /Beta /CrvA /CrvB
   /Omega /Gamma /Sigma /SinSig /CosSig
   /Q /gA /gB
  ] {0.} forall 
   /Theta0 -999.  /PhiMin -999
   /Matrix matrix
   /MaxCrvLen 99999 /Infinity 1024 %dup mul
   /Solutions [] /XIs [] /GivenCurve [] /GivenCrvPlot []
   /GivenBox  [] /NormBox []  %[-1.8 dup dup neg dup]
   /PhiArray []
   /BiarcData1 null   /BiarcData2 null 
   /G2neg {}          
   /Comment ()
   /OutputFile ()
   G2Options {} forall 
>> def
%[/G2DataDict G2DataDict length] ==
%---------------------------------------------------------------
% Solution dictionary:
% /Nu /Xi /Rw /WW /JJ /PW /QW /PP /QQ /HH1 /HH2 
% /IsSpiral (bool) ID 
% RB0 LB0 
% /Acon /Bcon                      % for debug
% /Spiral4 [] /CrvPlot [] Length
%---------------------------------------------------------------

% ======================================================================================

/Times-Roman findfont 14 scalefont setfont

%GenSecDict   begin : on top  
FigDict       begin
G2HermiteDict begin
G2DataDict    begin
BiarcDict /Ldiscont 20 put
33 dict       begin   % working dict
%countdictstack ==

0                            % << dict ?>> ErrCode
count 1 eq {%
   /GivenDataString (No given data!) def
   pop 1
} if
%                            % << dict ?>> ErrCode
dup 0 eq {%
   1 index /Input 1 Args
   type /dicttype ne {% any 
       /GivenDataString (Incorrect given data type.) def
      pop 2 
   } if
} if
%                            % << dict ?>> ErrCode
G2DataDict begin
   dup 0 eq {exch {def} forall} if
%                            % ErrCode
   Margin 0 lt Margin 200 gt or {/Margin 0 def} if
   Margin type /realtype eq {/Margin Margin 595 mul 210 div def} if % mm --> pt
   /XpageMax XpageMax Margin 2 mul sub def
   /YpageMax YpageMax Margin 2 mul sub def
end
%G2DataDict Pdict

%                            % ErrCode
dup 0 eq {%
   G2DataDict /UserG2Data known not {
      /GivenDataString (No /UserG2Data entry in input dictionary!) def
      pop 3
   } if
} if
                             % ErrCode
dup 0 eq {%
   G2DataDict /UserG2Data get type /arraytype ne {%
      pop/GivenDataString (Incorrect /UserG2Data entry in dictionary (not an array)!) Pdef
      pop 4
   } if
} if
                             % ErrCode
dup 0 eq {%
   pop
   /GivenDataString (GivenData: [ ) 
   UserG2Data 0 get type /nametype eq {(/) AppStr} if
   UserG2Data {%
      20 string cvs AppStr ( ) AppStr
   } forall (]) AppStr Pdef                     %  
   G2DataDict /UserG2Data get                   % [/key ...] 
   dup length 0 gt {dup 0 get}{/Empty} ifelse   % [/key ...] /key
   dup dup length string cvs 3 1 roll           % (key) [/key ...] /key
   G2InpDict exch known not {%                  % (key) [/key ...]
      pop
      [ (Methods: ) G2InpDict {pop} forall] ==  % (key)
      /GivenDataString GivenDataString ( Unknown method) AppStr 3 -1 roll AppStr Pdef
      5                                         % ErrCode
   } {%                                         % (key) [/key ...]
      exch dup length 1 sub get 48 sub 1 add    % [/key ...] n
      exch length eq
      {0} {6 /GivenDataString GivenDataString ( Incorrect array size) AppStr def} ifelse
   } ifelse
} if                                            % ErrCode

/TotalPages 1 def

0 gt {
   G2ErrorPage showpage stop
} if

G2InpDict  begin
G2DataDict begin
  UserG2Data aload length -1 roll /EXEC 3 Args cvx exec
  Q 0 ge {
     10
  } {
      Sigma 180 gt Sigma 0 le or
     {11}{0} ifelse
  } ifelse

0 gt {
   GivenDataPage showpage stop
} if
end end

G2DataDict begin
G2SetPhiArray dup /PhiArray exch def
G2SolveAll
/TotalPages Solutions length 0 gt {3}{2} ifelse def
ShowAll {/TotalPages TotalPages Solutions length add def} if
  
(G2SolveAll OK) ==
%Solutions {Pdict (EndSolDict-------------------) == exit}  forall

GivenDataPage  save showpage restore
%  countdictstack ==
NormalDataPage save showpage restore
AllSolutionsPage  save showpage restore

ShowAll {
   Solutions {begin SolutionPage end save showpage restore} forall
} if

%G2DataDict Pdict   

%CubicPage      save showpage restore 
end
cleardictstack

% to run PSclean add:          Cornu3 ABpp4 Ell2 Conc2 LogSpir2
%end end end end end end end
